---
layout: post
title: Analyzing Modern Malware Techniques Part 3
---

## A case of Powershell, Excel 4 Macros and VB6(part 2 of 2)
When I was watching [The Cycle Of Cyber Threat Intelligence](https://www.youtube.com/watch?v=J7e74QLVxCk&t=2823s) the other day I learned about the concept called “Biases” and how it interferes with researchers and cause them time delays and make big mistakes in general when it comes to research. In this part of the research I was no stranger to my own biases, I like to get my hands dirty, dig deep into binaries and understand EVERYTHING that goes under the hood. It’s simply my nature and my curiosity that can get the better of me. As I was researching this sample, I insisted for the first few days to analyze everything by myself, instead of using great tools that were in my disposal. I ended up spending A LOT of time attempting to unpack the loader instead of using other tools in my arsenal that aided me further analyze the malware itself including the heavily obfuscated loader, thus proving that I do as everyone else have my own biases and sometimes its better off to simply stop, reassess your goals and re attempt to understand the big picture. So here we go - Part 3 hope you enjoy this one :)

***

**Background knowledge required:**

1. Knowledge in C and Assembly
2. Knowledge in WINAPI
3. Knowledge in IDA and x64dbg
4. Novice experience with analyzing obfuscated and packed code
5. Knowledge in PE Injection techniques([Process Hollowing](https://github.com/m0n0ph1/Process-Hollowing) especially for this one)

**Tools used**

1. Any.Run
2. IDA
3. PEBear and PEID
4. Resource Hacker
5. Process Monitor
6. Process Explorer
7. x64dbg

**Goals:**

1. Unpack malware
2. Understand covert launching
3. Disable anti debugging and anti vm techniques(if there are any)
4. Identify basic host based signatures
5. Identify basic network based signatures

***
**Basic Static and Dynamic Analysis:**

> **Some side notes:**
> 
> This malware performs process injection, the memory addresses you'll see in my debugging pictures will be different because I had to re-execute the malware several times and because of the dynamic nature of memory allocation, you’ll sometimes see different addresses being shown.

Using [Hybrid Analysis](https://www.hybrid-analysis.com/sample/e6ffb945247085ceb6b2478c643dc337a35d5c0c17d2e4709c3a5842c9bcb3e3/5e25c5f7a2b4a8790d7d1bbf) I’ve collected some dry information about the activity of the [sample](https://www.hybrid-analysis.com/sample/e6ffb945247085ceb6b2478c643dc337a35d5c0c17d2e4709c3a5842c9bcb3e3/5e25c5f7a2b4a8790d7d1bbf):

**Anti debugging:**

![602x79](https://lh6.googleusercontent.com/xUa1Cc-czg_LPLS5sLbDBIvcKHynVewr0gyyX99JwR7B2BeuVef3uTJlBW1ycnriGY5txn8dftYCkcTALQkoSBa5LRsGazpLjW_3MjVavVizxgqO9sehLCd1Any2idy50cyJG_I8)

![602x68](https://lh4.googleusercontent.com/MpNb5G-cjs2J70hPI3a6L94gjs7nIAukBMPv60kY-PehWFezcMOfUCZacNMD1JhmoyovOqeKl9il9lRjEjPig8j_4jNH1XMCBOMlzk9XIrre6bN3rG8UpLxAk7D_Uo9xDhgeaGgb)

**Process Injection:**

![602x172](https://lh3.googleusercontent.com/HV8vOsAWyJzclsV4QN7NqBKDDzp6BUE0-RD5o9rfOmUTrbDz6Oxkkh6veNzzgb8bfIUQVGbYNAMwsvU6vx1qIjAU3568kZwHv3quLhLU3mqWwBw0WD1GNVcS07gWdw1M_o2isTiF)

**Dropped artifacts:**

![602x80](https://lh6.googleusercontent.com/0DIYReryv8rC-DEGADe6mKMzOLwDh6ONrj6-n56s69DPNLPrnk4FyF9jlIXchgDp68ZOiXgZWcD9KLSWHFmiZ-2-NmY7skPvfydvxPfl8OkgTOO0mkw8U0tYKtcQFFgbJx5RvrVL)

![602x77](https://lh5.googleusercontent.com/a4j-OZ2wIAVC2vWMkIXHbSpDg6mnBP6edl8ybQwbibd5V2iksPvFL_TtEFykZfiZbifEC4zL77CuMnsWd0LDJu1e-KtyKU5jBV8829Zp3Ik4r9AlnqTFRpKPJIlgvTEkGVlERJ7C)

Then I decided to load IDA and x64dbg to analyze the malware, which caused a significant delay in my analysis, I decided to stop and reassess the situation. The binary was so heavily obfuscated that It was getting real hard to impossible to analyze it without the usage of external tools. I decided to use API Monitor to collect a list of APIs the malware calls that could perhaps aid my debugging but the anti debugging techniques this malware deploys can crash, stop and confuse any debugger I threw at it including API monitor. The malware would simply not execute under any debugger attached. As a final resort I decided I’ll use process explorer and process monitor to understand what is going on exactly upon execution. Luckily for me - the malware did execute under a VM.

**Process Monitor & Process Explorer:**

It could be observed, under execution that first the sample would launch and begin to eat up CPU usage that indicates its unpacking, Then it would launch a sub process called RegAsm.exe, which is a known Microsoft application for registering .NET assembly. Malware frequently uses this binary to inject code into, and indeed as mentioned before hybrid analysis detected that memory is being injected into this binary.

![602x29](https://lh3.googleusercontent.com/sKXnfk5ukgNFab359s3xbSfFEWuK7WwgD-Y2xkjSZV7Gg6KqNkSnF7bVdMtnn3kRriav9CI1mDb2xQRRGZAbTRYcCUx8pbi54qaT8r-bgSVO9k74Jyy31yT77QfdW3oX7neh3CuN)

![602x80](https://lh6.googleusercontent.com/68Si2j-iqtjGArbG728zeUdUESsReHn5AGic3ZQ0NeYcEyTHmSDj1UODFVVSdPtE6ZvxR5BjnD2LKFppG-m666VUAyiatNK_PXXwIrGVyz3032yaGlG7F8XTfMtg5gPyYUTt2ePR)


The malware launches RegAsm.exe and it seems to launch with the sample path in the command parameters.

![602x67](https://lh5.googleusercontent.com/rnNPM7wCWVegpnTTIAt3dHtWGmp64McvnmubFBUid76VGFVg1noWAkCAToV-FGqY0YzEft5cc1DPoxtlSSgcmOHdbhByFoWD0iZRad8LztTmc-OPVKqRtYfFvGlOT9rNmIqzmBzu) 

Then it can be observed that as soon as RegAsm.exe is launched, a conhost.exe(cmd.exe) is launched with strange parameters:![|602x17](https://lh5.googleusercontent.com/II2QtyqaV4zeUaW3qOfRibrtGd7H01Os9xGXpfNoT4qfHa5EYMGMt8OWPW5ejKNtecfJ4Y8AXvLcFvRvkEsSzbQS-W2UenVQcDBAypu70r5fQEglRnyuQlREH4ESfdYaduNz3Phe)
After waiting for a while we can observe TCP network connections being made to remote addresses:

![602x55](https://lh6.googleusercontent.com/7g1YnjAJahlikovIA4yfClJ3nOVlTyYazFLOSkagB_aS49Lxp3X-R3EDQFzrOGxfC2OKais5Y88m_3I8rQtOFAgVXM738kfo5ioHeYpqaeLaBHuKV8JDnQqdB8y4ZdRnManDvxwg)

![602x97](https://lh4.googleusercontent.com/i2sydrg34cAgi6I0u7yMLwdCBhD7GRARZB1tZYS80GS8MxWMt_wzonuuXpA7-AVJKsy1vnQnvRkT5GFfdAobYy52c3pzpLxAOVlCpjBaU2JzaFnBU8U7ZLg-FK5RktY8qHLwRn6M)

![602x153](https://lh5.googleusercontent.com/xDkXWEtuMqsrv8DZs9GRovj80XlxTSo_NXhjwfbKdojE3z3MW8U_T9Y-WPsGsOrD_rs1g6aWq8fzTY5Hh5H0MahaFqAQzFdlxTnltCluMZM7cpaLUWQjgrfbJNdhawHscWtxa521)

![602x323](https://lh6.googleusercontent.com/Ha4cy-bsnr4EkXKuypgqalc-xzAKO3AHnr1WCSAXXbywhVlIdzXcAn2WnQDSFEKUz11zexJhc8sDnid7mDoMXHuzRRoYOH52gATu0pxnONLvxvgvKYY8h7DwsMNPMhfJdcLOInhL)

In addition we know that the malware drops a file into disk called **“OOlqs”** into the **%appdata%/aljwSjH/** directory, this file is created with hidden attributes. after executing the malware I examined the file and it seems to be a copy of **RegAsm** specifically the version the malware is launching as the victim sub process **(v2.0.50727).**

![602x73](https://lh4.googleusercontent.com/-w97WcPMWIf0T89I6bFiiHCbZ8ZkjfXINAs1RMG6cSUe8DiwKt09jjwFPTXpePPeEVyL1vKvU8xjgDWzsSZ7bebjoinX33q_ySjtxJPsMn6IyRlQpjz-DZ7QfoKG3wF5Uofa8FOz)

![602x133](https://lh4.googleusercontent.com/VnJ7-Tqb6edsPavd8MlYqYM1FPD5FL0UHAl9rt-A7VYqHBJL3HScePsFcAoMuQ410PwqsJMWV1XjAfdOSiToOuNMtjNBxi55wm69q2nI6r3m95Q6ph71SuwD1a-xzjyVcNO8pouq)

They contain the exact SHA-256 checksum which leads me to believe that the malware will launch its own dropped RegAsm.exe variant incase the specific version of RegAsm.exe is not found on the computer.

In addition RegAsm.exe is attempting to query sensitive data files:

![602x353](https://lh3.googleusercontent.com/DZdXhIpcoX5p9BGmipauYBP7GQiXJXokTjaI0sVBAWweLOy9jlEdd8qclaey6zxgbcnTsH8r-SFbPtafmYVuu6LBQLSHHQBKeMvt_eYZ8wZL9dUzHlLC09GlGQH8QUu1Dp8ZNl4L)

![602x12](https://lh3.googleusercontent.com/JzvBCeyL_CrWLqtBC0-2n6ThHrTv9aG3u-N4JPTTiB-XDshVFBwulSVs8Zis-Ki7Cyb2z4hIoyLRXm9eLMVKSqGSuV-KwlHAEKvPEkoP2zGIpSPgtaZOzgm9Wz69lByjI3hEzNfZ)

For the above example it is attempting to open Chrome and FireFox data files which strikes me as very suspicious. Later on I noticed the following:

![602x323](https://lh5.googleusercontent.com/3HLhSn9Ysy69oS7nJdB3e9haMd-xE0rw81y7GCn18yYbs6y0HqDv-18oNYhD2cSJgIAvZJ6pUEURJ1patD4uZfMp24_ft6b6d8-e_UiV-Yn74c0xnX5XcixImTK7Eo5I-GOUEUe0)

These are sensitive data files for various browser and other applications(Yandex, Chrome, Comodo, Firefox), this binary without a doubt is performing very suspicious activity.

***

**Advanced Static and Dynamic Analysis:**

We’ll have to find a way to dump the payload from memory. As I mentioned before, attaching to RegAsm.exe will cause it to crash, so this option is a no go. What we must do Is attach to the sample which I named **infected.exe** (just in case the malware deploys any tricks looking for SHA-256 checksum named processes or processes running containing the strings “sample”, “malware” etc).

Looking at this malware strings or imports in IDA yields nothing, no imports and no strings. We go straight into debugging.

In addition, to ease our analysis - lets install [SycllaHide ](https://github.com/x64dbg/ScyllaHide/releases)which will stop some of the anti debugging techniques this sample employs(thanks [@0x00dtm](https://twitter.com/0x00dtm) for the advice). Lets turn on all the options for anti-anti debugging as this will aid us greatly in analyzing this sample.

![602x549](https://lh6.googleusercontent.com/XaQxYCwp_QteUtz_tuOFRYNmH00erOXe0twvlz-86r1MLtIQ_M0g4kGswsvHCmSaO4U8LitJ6PNWApyDFLx9TQUGG55HAMdxMFGRzLlE9d-FmFPNiVgRlwu2pzPwkmTn8Iml3SYy)

In my previous article we loaded up the sample in IDA to find out its a VB6 file. I fixed it up with an IDC script but it didn’t help much, So this time I simply decided to execute it in x64dbg and make an educated guess that if we set a breakpoint on **VirtualAlloc** might lead us somewhere:

![602x67](https://lh6.googleusercontent.com/4buFFOqbYuYizQR3OVQ6Fpgho7sHWyMvIJ_wjk2X3fIq9atnKlBFY05gx7Un--yjCc0bhoIJwLuG32Uyo53FAAY4tHrOGSPeD_I3r8Wvllcoalkc5CKk6byQ_EMQ3KkYRG1CD4ub)
![586x51](https://lh5.googleusercontent.com/T_QS7Q0veZnlJb83zbCILoJmgZ_PbWUBgKZui51OM321W4GZKy7vNWnWHKpWy2gksv3EEwbKGktXsjztP9u1xz9J6j9YBiVhyd49QnHXfRmRQ9jiqhjQtG1m_hgn0dy-8By-IkhL)
The breakpoint was hit about 7 times, but each time it was hit outside our main module, on the 8th try I viewed the call stack and it seems to been executed from the main module this time:

![602x272](https://lh3.googleusercontent.com/sLxiE5DnuZP0SHxAoSPSUy9eZ4yUZIZ0PUqaR0W85aq-TSDx8WLuXKJnG5QXM_nHh9v4AcLY3RV5wJ5vgzhjT2ulbpRw51iAcNQRxo3KtP0nmmDR3vNJfLqsviC94xFOt3k1LLl6)
![602x67](https://lh3.googleusercontent.com/7VXngAxpMN-0-Xbg7qGEo5JHdD0OktK6735qaZqcaVe8GXhDM1Ivv-rmDQe4Ff5_lyGT_fXBFt8T8JLXVZx4vc3QnkGaDCzPQrOfckyPdODY5Erung5GEhGLtKu16cHWeFV8AKmo)
Interesting, I decided to view the contents of the newly allocated address:
![602x87](https://lh3.googleusercontent.com/ycMO8drp_GAJKocHmFTi4VMRWnCPRWxEC9BwVdVxVQ3iLjUBDV_gvm3wTukPi47yVyhvxqMdDeyrz637tMKznnlupRIP0O-ptB2KSzlIxZUq3kqVTyqpGTepZkK4xi81MV19ITHk)
Obviously it's empty, how ever I wanted to check if it would fill up. To check we must add a hardware breakpoint on the address **0x00250000** and make the debugger break if this memory region gets accessed. so let's do just that:

![602x327](https://lh6.googleusercontent.com/zRsFdyk2N5u2dW48amajbJ-LDATcms0O4iaqesGh5siY2N4CPhCpPnPAn-Qko6vCyjuJKi6_u74ZxGj8TFZirQO3Ofaiod2Zocsqso5kU98e0ZNDPCOqcPfGM4-1OqzXizv9-qoK)

And:

![593x163](https://lh5.googleusercontent.com/8XhA25vfjz-1L1ORWq5YJthMq3DNASz4Aom6WWt_hn6-iWubfzdrQ275AWRdY6g-iABKewHR6xZdwo3fPoc6bNgp_ys3ehgyh4LHzBy2LyLxOeESbamFeyyQnWb4OT95-KHwcc0Q)

but alas, this is no PE file header, and we try to continue looking for more breaks on **VirtualAlloc**, and continue executing the application it will crash. But then, perhaps this code is a shellcode, that might get executed? Hmm, lets try to find this allocated section again by re executing the sample.

So again I found the allocated area this time it hit on **0x00240000**. I decided to analyze the memory as code by viewing it in disassembly:

![602x441](https://lh5.googleusercontent.com/Tni_o-yiPzEOGM1fCMxK--fVeE8etDS1Z3g_EsI2ieDL3sjKmA7NaLMIT5CWglJvP2-da3D_J4_xML0-CBkWbW4b9xb547lCXVvumqBiWM74tPDUxSn7VaZ1S9-On_dVFsCQWbcH)

![602x108](https://lh4.googleusercontent.com/Dii8aCs8xuzpd6khr5kajS4Trug5dDr0bkz-RadGZFKriFjSV0uIhlGyBc-lOynKdv_LRtMEwcJh-1zvaaejz4Y3fb6DvnXo-G_dOP6yPHz5PbUVg0GU22TvpQT48YqoLqcmeD6e)

And it looks like valid code, So I decided to place a breakpoint on it.

but it did not execute.. hmm, Probably because I set it as a memory breakpoint and this binary is riddled with anti debugging traps, I decide to put a hardware on execution breakpoint on the allocated area and what do you know:

![602x220](https://lh3.googleusercontent.com/fqRJuxeD93agFHk6D9fQ57-985snVFpGT4pf51_1Ye7xrACM0Twog2b8iJaw9u_caPHX3f_gWdNw6ChMUxkxl5zMAJehL5JVFoMYJSd4Ml0fknf4P08fJWJy9Hyux71kdRWxYQLZ)
We break on the allocated shellcode!
The call stack indicates it was called from **0x0041B17F**

![602x24](https://lh3.googleusercontent.com/5ZZuFwoaTZ0JFIfpkuzZU0ptFMYY0NqGLjMNloxVrkXCUdH_1YrUXoShBEamm6hKuhsWB0JxvLWrc3guylymZcdRgYW2pA80XGGZr0yXwfihMHaJY5uK5eSwA6KjK1Ce_9E0rIRQ)
First thing I did was dump the shellcode using the **Syclla** and moved the memory dump into my Static Analysis machine, this code is not executable but we can analyze it on IDA. Since each execution this shellcode will be allocated in different areas it will be a bit harder to analyze it but the last 4 bytes of the code addresses have the same offset all the time so it's still possible.

Usually, when I hit this kind of code that I have no idea what it does so I decided to traverse around it to see if I find anything interesting. the first artifact I find is located at offset **0x52AF** from the begging of the allocated code, a call to **LoadLibraryA** is performed at address offset **0x52B8** and then a Call to **GetProcAddress** is performed inside sub_offset52E4 at offset **0x52FD**:

**IDA View:**

![536x60](https://lh3.googleusercontent.com/2D7GBVjL53ThVoveEgYPrBWNNPwf_uy54_GIwsv4Jg74m_jsLDKxWbQv0K4-jZS8fr_phGm5LOSoWUgx7fMfXCA3LTdzVNXdaXoGAynoGCTraC1gYU3w-Yq3wzIGH_eGci3iwvf4)

![478x53](https://lh6.googleusercontent.com/vG9vKBNAQB7OphRfYjTy-StR0Qprf438MZik0snouglxNhMhLo5bnUP9uzojn-q9Sf3CxdwW6ZFyJILSKCa5ps3UaczTp5BF9c-ZOAFMijhWTQGzFf-x5qGqOCz6bSSZKGR-RxIX)

**x64dbg View:**

![602x115](https://lh5.googleusercontent.com/4Cedv8Q1OniedKNdrlu3BibMu7Ga_4xEcVVgkO-oeB0XM-vQ0F6rAYQ42U9eEse70KPHTyw2bImZl9NUFlFsIR-ozu1vp6wHdNtJfcEuUb6Usj8JZ-eLeLt05m4Ow51bDn4O9-pZ)

![602x223](https://lh6.googleusercontent.com/lZyy4mZQor2ZkbMJXzbkFsz4F8A7aIe3cTZKgjQ-83M4GGwImYtB3gdUPqPHWBZMPBSg8CUO-ZUf8y1EczvwW5-wkXS72mMGjBKW0NZCsK5s1vsq2f6UsMok4tgh8QIVtWIfJa_r)

We can see that various API’s are being resolved and this is not uncommon for this type of heavily obfuscated malware, it is deploying what is called Dynamic API resolving which means all APIs will be resolved dynamically making the analysis much harder. As we Recall, I assumed that this malware will perform Process Hollowing on RegAsm.exe and the dry analysis we performed using Hybrid-Analysis actually gave us more prove that this in fact MIGHT be correct. Since we found the API resolving method for this malware, we can set up a breakpoint on **func_LoadLibraryCall**(at offset **0x52AF**) for this function and see if any API’s that are related to process hollowing or code injection will be met. I have reason to suspect this is might actually work because if we check the references for **func_LoadLibraryCall** we can see its being called a lot during execution.

![602x441](https://lh3.googleusercontent.com/7A7sDY4uqFAigvcxhn2CJ6FAz10QR0rIwHFwHcjWDXz4dR_zVcyW0SDBv0CN9hUlyF7NmJhRISR3VlTf-JPB9TFdZPNKZPyUlp03SYMOK9xtgSxxY5KiuZQhuwWixoSJO6MPq2oi)

So let’s be on the lookout for:

    VirtualAllocEx
    GetFileSize
    CreateProcess
    NtGetContextThread
    NtReadVirtualMemory
    NtWriteVirtualMemory
    NtResumeThread
    NtUnmapViewOfSection
    NtProtectVirtualMemory

A list of APIs I’ve encountered in the API resolving routine:

    TerminateProcess
    EnumWindows
    NtProtectVirtualMemory
    DbgBreakPoint
    DbgUiRemoteBreakin
    NtSetInformationThread
    NtAllocateVirtualMemory
    NtGetContextThread
    NtSetContextThread
    NtWriteVirtualMemory
    NtCreateSection
    NtMapViewOfSection
    NtOpenFile
    NtClose
    NtResumeThread
    CreateProcessInternalW
    GetLongPathNameW
    Sleep
    CreateThread
    WaitForSingleObject
    TerminateThread
    AddVectoredExceptionHandler
    CreateFileW
    WriteFile
    CloseHandle
    GetFileSize
    ReadFile
    ShellExecuteW
    SHCreateDirectoryExW
    RegCreateKeyExA
    RegSetValueExA

As expected I’ve extracted APIs that might indicated process hollowing.

I’ve noticed two interesting things about this sample regarding the API resolving, One is that each run these strings are loaded from the exact sample location **0x44XX** - **0x4XXX**, this means that we dump this memory section again and look at the strings in their decrypted form! also I think the author made a mistake because if we’ll view the strings through IDA we can see that he didn’t encrypt all of them:

![399x42](https://lh3.googleusercontent.com/E9tLzJwaNjylnSAuCvPNKcvYcFARA8-GuFW_A2ND30LT-yQxvhbSY4QpxyHE_2ngy2m24QXmtjM3N3YZzCxMkGE-D6BVaDOZTSyz3zWThFlCdMeXPZshG8l-lNHr1hx5nchp1zNT)

Anyway, on with the analysis, we can actually notice that during this API resolving the malware already spawned **RegAsm.exe** as a **child process** and we finishing looping around the API resolving function the malware terminates itself and we can see **RegAsm.exe** begins to execute independently.

We must restart the program but this time we need to choose the correct APIs to break on, If we break on these APIs using memory breakpoints the malware will detect this and force the debugger to stop execution on a debugger trap so we must perform this using hardware breakpoints.

We can only set 4 at a time, So let's choose the following APIs:

1. CreateProcessInternalW
2. ZwWriteVirtualMemory
3. NtResumeThread
4. ShellExecuteW

After the APIs are resolved we break at CreateProcessInternalW:

![602x81](https://lh4.googleusercontent.com/W5KiBcpisLMDk-UkK6OiJY2vONVtajqatmDo_0Hn4Uodomllmt2gzFjOXd0TIV19duepgq3Zql7UlsiPbWQ_z3VWh9jBXYrqGP5rQuAHckEUHblJyUwr-yZCKwqbHo1ZHSi7LaJm)

We can view the parameters being passed to the function, and unfortunately this API is not documented AT ALL. but we can kinda make sense from whats going by looking at [CreateProcessA](https://docs.microsoft.com/en-us/windows/win32/api/processthreadsapi/nf-processthreadsapi-createprocessa) which calls ***CreateProcessInternalW***.

    BOOL CreateProcessA(
    LPCSTR lpApplicationName = RegAsm.exe
    LPSTR lpCommandLine = Our sample
    LPSECURITY_ATTRIBUTES lpProcessAttributes,
    LPSECURITY_ATTRIBUTES lpThreadAttributes,
    BOOL bInheritHandles,
    DWORD dwCreationFlags = CREATE_SUSPENDED(0x00000004)
    LPVOID lpEnvironment,
    LPCSTR lpCurrentDirectory,
    LPSTARTUPINFOA lpStartupInfo,
    LPPROCESS_INFORMATION lpProcessInformation
    );

This is our first indication of process injection. First the malware spawns RegAsm as a suspended process which can be viewed in process explorer:

![501x55](https://lh6.googleusercontent.com/78gsIMr5xeMDHVableNAaVWmO5nf8VxNKe_aqEHUSIUf1ah34KYAH-3a2ple4LIX4HnjvAJPpVUXLVqOk70kdkdntGkIHuz7LsNyY-zmj62FIjeOZ4S5KeChkd9B45NzUaHuanbm)

Let's continue.

Then we break on **ZwWriteVirtualMemory**:

![468x67](https://lh5.googleusercontent.com/M9n4yZvul7E_E3HZHYtoJvPQWYwjilsiErQPNLuLHw4Nkk5Yn6ze-Jt_WdLz9whYahTOO3SBxSHETkKvRZtEY4FF9stT9xl_anIYGfFuu8ggq9zUTEncftBHrcz41t9_dcu7pA6N)

The [undocumented Internals](https://undocumented.ntinternals.net/index.html?page=UserMode%2FUndocumented%20Functions%2FMemory%20Management%2FVirtual%20Memory%2FNtWriteVirtualMemory.html) website states that:

> “**NtWriteVirtualMemory** is similar to WINAPI [WriteProcessMemory](https://docs.microsoft.com/en-us/windows/win32/api/memoryapi/nf-memoryapi-writeprocessmemory). See Ms SDK for detailed description of parameters.”

> Side note, In userland calls to Nt prefix and Zw prefix dont matter they are both the same, I assume malware utilizes these calls to avoid AV detection since these APIs might not be monitored.

So let's look at that:

    BOOL WriteProcessMemory(
    HANDLE hProcess,
    LPVOID lpBaseAddress,
    LPCVOID lpBuffer,
    SIZE_T nSize,
    SIZE_T *lpNumberOfBytesWritten
    );

hProcess holds the handle to the process we want to write, **0x100** corresponds to the **RegAsm.exe** Process, this can be seen in the Process Explorer:

![602x17](https://lh4.googleusercontent.com/RfjGJ9iNduCbHmPI9NXvkrB_JRRMNE1CZucP_BiIPjMm7yv0eJ4NtEKK_nEJ1VzF9udhpJ1zu5do1nmxZ4jOK-8L8LhSdBXSKQ-RqpQn_trd1S8Wx5K3lIBWjg8xSsf5cYp2Db_W)

we’re writing **0x5DC** bytes starting from address **0x005F7D00**. I looked it up in the dump it doesn't seem to contain much of interest to us. so I'll continue with execution.

We break on **ZwWriteVirtualMemory** again!:

![186x66](https://lh6.googleusercontent.com/WDWf3sWA0OjBTsYfkXynyQVz4o4wi12jkVKkjvAT4JbjGfgL_DpWM_YfnVnO-oMQKOZQu8YL5SzGqkIIuKnJKCnGws2hPnuYeN4phHI2b3MO1GmZhwaZ9lYViQ_dCEiMFyJau311)

This goes on 2 mores times until I hit something interesting:

![168x69](https://lh3.googleusercontent.com/049WD4YI39DUTZAdTXgHiV6WbeHtO_aQcYA1kzrwyCdGDj0f1peF5u0vomqAusk20Z-iuKPlt4N11ujL5LZFmXGCYVFaOMJgfzOtgyXpYL0Mfj4eGtZuiWqAnNk4HgfkWOEiseJI)

huh.. it seems to inject the shellcode we are debugging right now straight into **RegaAsm.exe**, we can check this by viewing **0x4B0000** in disassembly view in x64dbg:

![602x303](https://lh6.googleusercontent.com/LYNr5jcHBS0IxFhqncbsm3jzopOfQivGyF8sHQe8gqxbxPFSBD3Tmi4D1SZfQrYxyEbLc9NCMfun4dQc1mSbTWR5ULSm_kvcTf_leXoiEVthNBoZDu9R1iRfHtQgrZQuzsMJsF0A)

Next API that is **NtResumeThread** that will probably cause the newly created thread in **RegAsm.exe** to execute and we don't want to execute that because the malware will continue execution! Now what's really cool here, is that we can attach to **RegAsm.exe** and put a breakpoint on the shellcode and resume the new thread and break on the malware again!

Now I’ve attached to RegAsm.exe:

![578x148](https://lh5.googleusercontent.com/3DDtnxDezE5RT1amZp50Iyb0fiURgaRgSwT1oys04BbcGZqRDYxQsGL9DvoSKjYzJMKkRhJl9-Y6NJOnhj7hKsFfhC7-XkbaasuwDDWk22e_tzYmyoDwCnZ8ZYUngy9QFaPwaxRB)

If we got in the Threads tab in x64dbg We see a suspicious thread with **EIP 0xD0000**(Will be different on your machine) but the and it seems to be marked as the main thread. let's go into that thread and place a breakpoint at its start address and simply resume it.
![602x143](https://lh6.googleusercontent.com/c6cMzLb6Ux6JoFqaoVdH1B9NFtz5r2x0v2nBJF2jwNVUvb3qPR3QPJJkg4Xc7bKlVl1S-79Vs0YUbTUOAeeyX5lRwEYMzNtOf2fVmPACu4aWXGFP8ma_9ZNAiAbWybp64MWfjArX)

And we hit it our breakpoint!

![602x44](https://lh6.googleusercontent.com/MVOQmE2H0jc8o0iyJA8Hogw8bb27agbaiorL9GowQ8y7k8vhiKCRoagFK0boGxISw4ck1YXhj5gN5pjWdazGs12ZW9Z3KujhT1UYI8LHoq2PXyLlHtkkAmY9zGOb5TpgCTjWJ3yJ)
In the case of this malware, it was not a classic process hollowing attack but an interesting case of code Injection, because in classic case of process hollowing, the attacker must unmap the original PE out of the process and thus hollow the process and then remap his own PE into the process. In this case it seems that the malware maps just its code into the memory of the other process and sets the main thread to execute on this newly allocated code. This method is easier to execute but more detectable, as it would seem that new shellcode is being run from a suspicious area in the code that does not match the original entry point of the image located in the Optional Header field. In addition the malware author did not bother masking the injection and we can see that the executing code is going to be executing in memory which is in **READ, WRITE and EXECUTE** privileges:

![194x14](https://lh3.googleusercontent.com/6912ogQZ3zqg-sO8n8iB2JcMadAaVFpqZOBcu2mU79sKYvQDESTx_rF0QtbEEaKab22ky5pSILQCzuVH5DuXB9mXZmrOp1n8x-IeQ9uK99OKsamDb-Jj8fvT3vNf3sJQBSA-vp6b)

This is highly suspicious.

Next Let’s put a breakpoint on our API resolve routine at offset 0x52B8 and see what new API’s are going to be called in this new executing code.

    TerminateProcess
    EnumWindows
    NtProtectVirtualMemory
    DbgBreakPoint
    DbgUiRemoteBreakin
    NtSetInformationThread
    NtAllocateVirtualMemory
    NtGetContextThread
    NtSetContextThread
    NtWriteVirtualMemory
    NtCreateSection
    NtMapViewOfSection
    NtOpenFile
    NtClose
    NtResumeThread
    CreateProcessInternalW
    GetLongPathNameW
    Sleep
    CreateThread
    WaitForSingleObject
    TerminateThread
    AddVectoredExceptionHandler
    CreateFileW
    WriteFile
    CloseHandle
    GetFileSize
    ReadFile
    ShellExecuteW
    SHCreateDirectoryExW
    RegCreateKeyExA
    RegSetValueExA
    InternetOpenA
    InternetSetOptionA
    InternetOpenUrlA
    InternetReadFile
    InternetCloseHandleA

One can notice that this time, the code resolved 5 more APIs! these are the internet APIs.

Now after we resolved the APIs and probably decrypted the payload we can do two things, One is collect all the API’s we find of value that can contribute to our understanding of this malware and dump the decrypted form of the malware as we can we can extract some strings out of it which can be done at your own machine because as we saw the strings are always located at offset **0xXXXX44XX** and can viewed in the IDA string view here is an example:


![602x400](https://lh6.googleusercontent.com/ZlJ7sx0UQnju2r-C-pY5xEptlpmKY_O75A6opXMiB3VjpD0uXRDbx704qi-PvfYiQqDwTqOYK3DT8Xh_mgDnzzu_xkTUMChsD7AaWK_beO6c61fUlonO2QlDLMOWUAOy-KdsAG65)

![602x79](https://lh6.googleusercontent.com/9ZgoO-dEKUX29Xlt6TyiN1uzKCIu326En-iA38bgv6P4AJMMeIR1HpL7w0dKYg3qNKSCaCJBcjXZSAu6yhl17BuDSiFgCNJvTg-oyN1cVLIJwA-vW_pOCoSHLwOWBhc4LNLZDVcO)

These decrypted strings can aid greatly in understanding this malware more in depth. The strings marked in red indicate that the malware might be downloading more artifacts off the internet and might be attempting to hide itself in traffic using legitimate looking network strings.

Wow, Alright! we gathered a lot of information, and we might get lost if we don't summarize our findings and understand what is our current status so let's stop for a second and reassess.
***
**Where should I continue from here?**

We’ve covered a lot here and this article is getting really long. There is so much to go from here -

* We’ve managed to unpack the malware first stage loader and the payload
* We have a list of APIs that can aid us explore the loader and the payload
* We understood the malwares stealth injection technique
* We managed to load the payload into memory and gain control over it
* We got a lot of artifacts and IOC’s that can aid us greatly in deeply analyzing this piece of malware.

This was no easy task, we had to defeat a packer and really tough obfuscation techniques. When I began writing this post only [12 AV engines](https://www.virustotal.com/gui/file/e6ffb945247085ceb6b2478c643dc337a35d5c0c17d2e4709c3a5842c9bcb3e3/detection) managed to detect this file as malicious so let’s give us a tap on the back.

See you guys next time!

***
**Sources:**

Sample used(SHA - 256) - 6ffb945247085ceb6b2478c643dc337a35d5c0c17d2e4709c3a5842c9bcb3e3/5e25c5f7a2b4a8790d7d1bbf

https://github.com/m0n0ph1/Process-Hollowing

https://www.youtube.com/watch?v=WlE8abc8V-4

https://anti-reversing.com/Downloads/Anti-Reversing/The_Ultimate_Anti-Reversing_Reference.pdf

https://www.amazon.com/Practical-Malware-Analysis-Hands-Dissecting/dp/1593272901

https://www.hybrid-analysis.com/sample/e6ffb945247085ceb6b2478c643dc337a35d5c0c17d2e4709c3a5842c9bcb3e3/5e25c5f7a2b4a8790d7d1bbf

https://anti-reversing.com/Downloads/Anti-Reversing/The_Ultimate_Anti-Reversing_Reference.pdf
