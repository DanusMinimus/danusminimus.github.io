---
layout: post
title: The Art of Malware
categories: [Malware Analysis]
tags: [viruses, dos, freedos, tdl, cih, malware-history, virus-development]
---
## Bringing the Dead back to life
I would like to dedicate this post(or perhaps series of posts) to [Mark Ludwig](https://en.wikipedia.org/wiki/Mark_Ludwig), the author of The [Giant Black Book of Computer Viruses](https://www.amazon.com/Giant-Black-Book-Computer-Viruses/dp/144140712X), who passed away in 2011. You‚Äôve sparked my initial interest in viruses back in 2013 when I was only 15, and although back then I could barely understand your book I would like to make some closure in modern day era. You saw viruses as art and self-expression, back then that message resonated with me in levels I cannot describe and to this day I am affected by it. 

Thank you.

**DISCLAIMER:**

I do not condone the development of malware for malicious purposes, the information obtained from this post is for educational purposes ONLY. Act with a clear mind, healthy conscious and responsibility please.

***
## <span style="text-decoration:underline;">Philosophy as a case for developing malware</span>

Malware today is automatically described as a bad thing. Well it is, it‚Äôs called malicious software for a reason, but it can be viewed as a form of self-expression or art. One might ask ‚ÄúWhat the fuck?‚Äù but before you get into a rant about that why malware is made, that it‚Äôs motivations are to steal and to cause damage and nothing good comes out of it let me set up a different point of view for you. Usually malware requires creativity and to circumvent and bypass layers of defense or to manipulate the system it‚Äôs running on. the author of the malware must implement his ideas in a smart and creative way. Yes, it‚Äôs true that a lot of times it‚Äôs done terribly and sometimes the author either blindly copy pastes code of other malware authors or researchers but usually when its done with some innovation in mind the result is usually interesting. Perhaps not for the organization being attacked, perhaps not for the end user who gets his data stolen but FOR me, the analyst who ends up analyzing the product of the author, is very interesting. 

Let‚Äôs take [TDL3](http://static1.esetstatic.com/us/resources/white-papers/TDL3-Analysis.pdf)/4, A rootkit that caused significant amount of damage back in 2010-2013. Implementing hooks in the lowest levels of the kernel to avoid detection, creating its own virtual file system and building an actual virus as the first stage of attack. It infected computers in such a large scale that Microsoft literally pushed out specific mitigations against it, tools were developed to specially target it as it was not easily recognized by most anti viruses until late stages of its development and it even caused a large number of computers to crash when Windows updates were issued because it modified the system. Microsoft, as a mitigation attempt, simply didn‚Äôt install the update on the infected system. That‚Äôs just insane!

Sure, the main goal of the authors was to gain money, but they also proved to be creative and to have a deep understanding of Windows Internals in such depth that they were able to use the system against itself in ways that were not seen before. Even after Microsoft issued the new policy that all windows drivers must be digital signed by Microsoft to execute in the kernel, the authors pushed out TDL4 for 64-bit systems which started utilizing bootkit tactics to infect computers. The press called it [‚ÄúIndestructible‚Äù](https://web.archive.org/web/20111012123012/http:/technoglobes.com/2011/07/indestructible-tdl4-botnet/). Malware wanted to be packed with TDL and Rootkit authors wanted to be TDL. [The fun ended mostly when the authors were arrested](https://en.wikipedia.org/wiki/Alureon). 

If you read analysis repots of TDL you can‚Äôt stop gasping, why? Because it‚Äôs simply designed in with such creativity in mind that you can‚Äôt help but appreciate it.

Let‚Äôs take [CIH](http://virus.wikidot.com/cih) as another case, A virus that was unleashed back in 1998 with reported costs of [1 billion dollars of damage](https://en.wikipedia.org/wiki/CIH_(computer_virus)) and infecting [~60 million machines](https://en.wikipedia.org/wiki/CIH_(computer_virus)). Was developed to prove that AV companies are not worth their slack. But the unique way that CIH infects a computer is just mesmerizing. It scans the files for empty gaps, and then splits itself into chucks and injects itself into them. On its payload 26<sup>th</sup> of April triggers a MBR overwrite which renders the computer unbootable. Destructive? Yes. Amazing? Also, yes. 

Malware in my point of view is as bad as bacteria, yes in our eyes it causes damage and might kill people but also, it‚Äôs a living organism acting on its nature. Our perception of that nature is bad because we attribute motivations to it, but without the authors motivation it‚Äôs simply just is and sometimes its incredible. 

Yes, sometimes malware is just there to steal data and encrypt your files which in all honesty is kind of boring and annoying like mosquitoes and bad art, but sometimes it‚Äôs interesting and amazing like watching [a parasitic worm turn snails into disco zombies.](https://www.wired.com/2014/09/absurd-creature-of-the-week-disco-worm/)

***

# <span style="text-decoration:underline;">Entering the morgue</span>

‚ÄúAlright Danus, enough with the philosophy, let‚Äôs get into it!‚Äù Yeah yeah.. alright let‚Äôs get into it. First, we must choose what exactly we are going to be developing, and who is a better candidate than viruses. What is a virus? Isn‚Äôt all malware a virus? No.

Viruses is by defined by Wikipedia as ‚ÄúA **computer virus** is a type of [computer program](https://en.wikipedia.org/wiki/Computer_program) that, when executed, replicates itself by modifying other computer programs and inserting its own code.<sup><a href="https://en.wikipedia.org/wiki/Computer_virus#cite_note-Stallings_2012_p.182-1">[1]</a></sup> When this replication succeeds, the affected areas are then said to be "infected" with a computer virus.‚Äù

And yes, it is malware but its not a Trojan or a Worm. A [trojan](https://en.wikipedia.org/wiki/Trojan_horse_(computing)) doesn‚Äôt self-replicate and is sometimes referred to as bacteria and a [worm](https://en.wikipedia.org/wiki/Computer_worm) unlike a virus or a trojan doesn‚Äôt need user interaction to spread itself as it does so independently using the network. 

But why a virus? Well, they are old and not much made anymore([VIRUT](https://en.wikipedia.org/wiki/Virut) infecting [malware developers](https://blog.malwarebytes.com/threat-analysis/2018/03/blast-from-the-past-stowaway-virut-delivered-with-chinese-ddos-bot/) ahem). Most of them were not made to steal data and mostly were used as internet graffiti. Developing viruses proved skills, creativity and innovation back in the glory days of viruses but they are hardly utilized today because its hard to generate profit out of them. As far As I see it, that‚Äôs where it all started from and Intended to start from the beginning.

Now we need to choose a system to which to run these viruses on. I think a good candidate is Windows 7 x32 because its modern enough but limited in its defenses so it‚Äôs a perfect candidate. 

Now we need to choose a virus, and what better place to find them than [https://malware.wikia.org/wiki](https://malware.wikia.org/wiki), [http://virus.wikidot.com/](http://virus.wikidot.com/) or [https://vxug.fakedoma.in/](https://vxug.fakedoma.in/). But before we actually develop a real virus we must learn the basics of virus development using [The Giant Black Book of Computer Viruses 2nd](https://archive.org/details/TheGiantBlackBookOfComputerViruses2ndEd./mode/2up) edition which can be found online in the internet archive.

First we‚Äôll emulate the viruses on [FreeDOS](https://www.freedos.org/)<span style="text-decoration:underline;">(get your copy here)</span> or on old versions of Windows(95/98) to view how they actually executed(because learning how different legacy operating systems work is fun) and then based on how they executed back then we‚Äôll attempt to some how recreate them in Windows 7. Why DOS though? Can‚Äôt we just start with Windows? Well, yes, we can but I think one should understand why things today are as they are. What is protected mode and real mode? how virtual memory works? what defenses OS's and hardware incorporate today that didn‚Äôt exist before? It is fundamental knowledge to understand why things are they way they are. 

Why FreeDOS and not MS-DOS? I‚Äôm not that old school ‚Äì FreeDOS provides us a platform to emulate our DOS viruses but has many modern useful built-in tools integrated into it plus VMware communicates perfectly with it. [Here‚Äôs a copy](http://www.ibiblio.org/pub/micro/pc-stuff/freedos/files/ebook/using-freedos-24/using-freedos-24.pdf) of the user guide to FreeDOS.

Additionally, we‚Äôll be coding in pure assembly and I‚Äôll be using [NASM](https://www.nasm.us/) for FreeDOS and [Visual MASM](http://www.visualmasm.com/download.html) which as a very cool IDE that will allow us to code Windows assembly. but you can use any assembler you‚Äôd like. Why assembler though? Can‚Äôt we make viruses in C? or C#? or Java? No, because one; it would be defying the great tradition of making them in assembly and two; high level languages will not allow us to get creative as much as we‚Äôd like. 

**Alright what else, please download:**



1. **[Sublime](https://www.sublimetext.com/)**
2. **[VMware](https://www.vmware.com/)**
3. **[X64dbg](https://x64dbg.com/#start)**
4. **[Cutter](https://cutter.re/)**
5. **[PEBear](https://hshrzd.wordpress.com/pe-bear/)**

**Background knowledge REQUIRED:**



1. **Experience Intel x86 assembly**
2. **Experience in C development**
3. **Basic with windows Internals**
4. **Basic in x64dbg**
5. **Basic experience with UNIX or DOS shell**

**What I‚Äôll be teaching you:**



1. **Technical Knowledge**
    1. **Teach the reader how to program in DOS and Win32 assembly**
    2. **Teach the reader the basics of old school virus architecture**
    3. **Teach the reader about computer architecture history and Windows Internals**

1. **Researcher Skills that you will have to acquire**
   1. **Data collection:**
        1. **Learn how to google, all your answers are found within the internet.**

        2. **Look for only what you need to know. For example, if you are reading about Virtual Memory ‚Äì don‚Äôt start digging into the how the electricity circuits in the MMU operate. It is a waste of time in the context of this article.**

        3. **Learn to use CTRL + F, it will save you a lot of time.**

        4. **MSDN is the bible of Windows API and it usually has all the information you need about specific function.**
 

    5. **Structure:**
        1. **Make a list of all the things you don‚Äôt know or don‚Äôt understand, break them into subcategories and make an effort to understand them.**
        2. **I list a lot of resources, save time by reading only what you need to know.**

        3. **Don‚Äôt get lost in the massive amount of information, breath.. and orient yourself to reading only what is necessary.**

    6. **Seeing the bigger picture:**
        1. **If you see something you don‚Äôt understand in my code, don‚Äôt drown in the specifics. If it‚Äôs necessary to get into it I will get into it.**

***
## Note
This is not an assembly tutorial, nor is it a Windows programming tutorial. It is assumed the reader can read and write basic Assembly, and has some experience with the Windows API. If the reader does not posses this knowledge, the information below might be a difficult read.

**Alright, let‚Äôs put our surgeon coats on and don‚Äôt forget the gloves cause we‚Äôre entering the morgue!**

![624x414](https://lh6.googleusercontent.com/vkazdup-JSKECTBnrK-S_0VYLQdvCVr2UFpVJ59xo5m1W0OsGL_v6DHuY1UhOxVCdldRrd5Sps2fh4qCmcMMjtVktbkODW9WHSkPPr9h-a6g87zzKJjUoorg4DLSzPEIxo6UhuCdA6ZIgEIvtQ)

***

# <span style="text-decoration:underline;">Setting up FreeDOS using VMWare</span>

Run the **FreeDOS** image in VMware and it should install itself with relative ease. 

Welcome to 16-bit real mode heaven. No memory protection, no protected mode, no multithreading no nothing. Just pureness. It‚Äôs my first time here too, I‚Äôll be honest. 

Let‚Äôs start by installing **NASM** so we can write assembly here so type down **FDIMPLES** and you should get this window:

![624x133](https://lh3.googleusercontent.com/7PVCwOUlqI3E1hGQ5msjhPEmEXLOYHelQ9PrCdjbttL1JPTo8GdATIDqw-REKTVdl5ivFHKp3sCf440rduZH4nNkbqX_3vzZsLO6wk2hhRLWPv1KNv5Dgr_BcHepn33-9gFA50_ApmZ1aiDyqg)

Use the arrow keys to scroll to ‚Äú**Development**‚Äù and then scroll to ‚Äú**FASM**‚Äù or ‚Äú**NASM**‚Äù. Now you can use the arrow keys again to quit.

## <span style="text-decoration:underline;">Intel x86 Real Mode Basics</span>

So before I start explaining here is [the Intel Assembly Manual by Michael Chourdakis](https://www.codeproject.com/script/Membership/View.aspx?mid=358302) if you get confused or stuck in my explanations you can always go back there, he explains it perfectly and also more in depth than I‚Äôll explain here in my article. If I make a mistake, feel free to correct me privately üòä 

So Real Mode is the bare basics state of the CPU, the BIOS runs on it. There is no memory protection, no virtual memory. Basically, it‚Äôs free for all. 

What matters to us in the scope of this article that DOS executes in real mode, this means only one program can run at a time there is no multi-threading. 

Memory access is limited to one megabyte and unlike in a normal windows environment there is no separation between the kernel and user applications, everything can access everything. So, applications can run anywhere in memory and have access for all memory, basically anyone can do anything. This what makes DOS such a fertile ground for viruses.

*** 
## <span style="text-decoration:underline;">Register State in Real mode</span>

**General Purpose registers 16-bit registers**

AX, BX, CX, DX that you can split to their low or high counter parts

**Special Pointer Registers 16-bit registers**

BP(Base Frame pointer), SP(Stack Pointer), IP(Instruction Pointer

**Segment Registers 16-bit registers**

ES (Extra Segment), DS (Data Segment), SS(Stack Segment), CS(Code Segment)

**Indexing Registers 16-bit registers**

DI (Destination Index), SI (Source Index), BP, SP ‚Äì These are the only registers that a programmer can use to indirectly access memory so executing mov ax, [cx] will not work.

**<span style="text-decoration:underline;">Memory Segmentation</span>**

In Real mode programs access physical memory directly, there is no virtual memory abstractions. Memory was one megabyte long, but it was accessed through a 16 bit register base address and a 16-bit offset, This allowed to keep the registers 16 bit aligned but to extended memory to one megabyte. So, **Segment**: **Pointer**. One segment can reach 64 kilobytes. Why is this needed you might ask? Well it‚Äôs a logical memory abstraction, it helps to keep the memory access organized in the sense that each segment represents its function; Data is stored in the data segment, code is stored in the code segment and the stack is stored in the stack segment.

So basically, say our program has a **Data segment** that starts at **0x2000** and we want to access the **10<sup>th</sup>** byte offset of that segment we‚Äôll do that by referencing the memory **DS**:[**10h**]. but how is that calculated you might ask? Well we take the segment register value and multiply it by **0x10**, so we append another zero to it and then add the offset. 

**0x2000** * **0x10** + **0x10** = **0x20010**. This technique allowed programs to access up to 1 MEGABYTE OF RAM! Because the final value calculated is 20 bits long. 

## <span style="text-decoration:underline;">Disk Operating System (DOS) Architecture</span>

Even though DOS can access up to 1 Megabytes of memory, the memory above **0xA000** is reserved for the system so **DOS** user applications could only access the lower 640 kilobyte boundary. 

![360x342](https://lh4.googleusercontent.com/6AbtHcMU-Lv1M4PNjqt-mLm45skbJj97eIcfjLy7X3JRVZUXK78vjLYPzXU1Yg-a717zVZC6hRgpHl0-vMzdoIpBbTP4vGv6JRxo_lfweZ-6Dw8V4hcrp_uZAayvapY0_JvvTQku9EJAF3MQ7g)
[credit](http://www.philadelphia.edu.jo/academics/qhamarsheh/uploads/Lecture%2020%20----16-Bit%20MS-DOS%20Programming.pdf)

The first **1024** bytes (or first kilobyte) of the memory contains **BIOS** and **DOS** Interrupts. this memory area is also called the **Interrupt Vector Table (IVT)**. There are three types of interrupts ‚Äì software interrupts which are triggered by the software (e.g. throw keyword in python) or in our case, **DOS**. Hardware interrupts which are triggered by external devices. Additionally, there are exceptions which are triggered by the CPU itself, there are three types of exceptions (faults, traps and aborts). 

Hardware interrupts are not always expected, and the CPU can set them to be maskable(ignored) or non-maskable (cannot be ignored). 

An example for a hardware interrupt would be interrupt number 9 which is issued when a key on a keyboard has been pressed. A good example for an exception would be interrupt number 0 which is triggered when the CPU is attempting to divide a number by zero. An example of a software interrupt which is handled by **DOS** itself would be interrupt number **21h**, which is the **DOS** **API** service.

Under **MS**-**DOS**, the **BIOS** handles interrupts **0-31** and **DOS** handles interrupts **32-63**, the rest **64-255** can be user defined. There are many types of **DOS** and **BIOS** interrupts and they all can be viewed in [here](http://www2.ift.ulaval.ca/~marchand/ift17583/dosints.pdf). 

The **IVT** can be treated as an array, each cell in this array contains the address of each interrupt in memory. The lower two bytes are the location of the offset where the interrupt code is stored, and the upper two bytes is location of the segment where the interrupt is stored. 

So, say we have linear address line at **0000**:**0000** which contains [**10**,**20**,**30,40**] the offset of the first interrupt would be **0x2010** and the segment of the first interrupt would be **0x4030**. Wait Danus, you got it reversed! not I did not, don‚Äôt forget the intel CPU is built with little endian architecture which means the least significant byte is stored first. So, the address of **INT 0** mis **4030**:**2010**(or to get the physical memory address **4030h*10h+2010h = 42310h**)‚Ä¨

To execute an interrupt from the **IVT**, we use **INT &lt;index in hex>.**

Can we view the **IVT** somehow? Yes! We can use the **DEBUG** utility which can be used as system debugger utility. It allows us to dump and view memory, assemble instructions directly into memory and execute them. Since there is only one core and only one program running all the time, we can play around with DEBUG to debug the entire system much like a kernel debugger. But be careful, because as you remember we have access to entire memory of the system, and we have no limitations. 

Let‚Äôs view the **IVT**. Let‚Äôs execute the **DOS** ‚Äú**DEBUG**‚Äù command and then use **D** for dump and view the contents of area **0000**:**0000** which contains the IVT.

![624x173](https://lh6.googleusercontent.com/Dz_tcHsMCEo897dzee8cdpEhDK4YA4WpzjGk1me00AmyeniaikcDZ_EjPNWi07ZwTO3bv1WC_4Oj7aVJloTzxPsvgt0Xi3vvWBQ5dJxolaUSW17JO_rojSav5-57n2vH5L6SmOm_6LH2Hs0Yig)

So, **0364:1DB6** is the address of **INT** **0** and **0364**:**1DBF** is the address of **INT** **1**, etc..

***

## <span style="text-decoration:underline;">Writing a basic COM overwriting Virus in DOS</span>

Let‚Äôs examine the mini-44 which is called like that since it‚Äôs only 44 bytes long virus from The Giant Black Book of Computer viruses at page 29. I‚Äôve modified it to a MINI-51 for the sake of this post and Its modified source that I‚Äôll be using can be found here on my GitHub:

[https://github.com/DanusMinimus/MalwareArt](https://github.com/DanusMinimus/MalwareArt)

The original file was found at [@TMZ github(Your‚Äôe awesome TMZ!)](https://github.com/guitmz/virii) 

![316x450](https://lh6.googleusercontent.com/lehxAL9VoN4pySWlvZEtdoOie5zKCOdpt5TxHJAFBs8_68sTNAJkxlh3-049I--_cp3QZKjryzKxk_cYAxYqA-4Klp6DhNoNxAbJCC3zcbkaG-k_ptAMgY4LZDuu3KYX2j3VB-gs9DQvwi6b1g)

I‚Äôve edited the virus a bit to make it work on **FreeDOS** and **NASM**. I didn‚Äôt change it all too much, but I advise you to apply the changes I‚Äôve added to the file yourself. (Because of my edits the mini 44 turned in to a mini 51.)

Before we begin analyzing this piece of code, we must understand something about **COM** files. They are built around the tiny model which is defined as:

‚ÄúThe tiny model. Everything must be included in a single segment (**COM** file).  Pointers are near.‚Äù

The maximum size of a **COM** file can only be 64 kilobytes, and everything must be contained in one segment, meaning all jumps are relative to one segment and cannot jump beyond the 64-kilobyte boundary. The Stack, data, and code all must reside in this one segment. Additionally, a **COM** file begins its execution at **100h**(h stands for hex). The first 256 bytes of memory are reserved for the **Program Segment Prefix (PSP)** which contains various information and function calls that the **COM** file can use. The **PSP** is relic of the past days and was created in DOS to maintain compatibility with old COM files. The following data can be found within the PSP:

![624x432](https://lh3.googleusercontent.com/w4WhiaE1RCaaIE58b11YDUc2LbKvsC5z1rXSdTrep8Ywwgquj17M1A3B6p3XX7_ymTvpzBKXupHc1Z-qrfsNBm2Mn4v-EVKuGzWX4yeLaoqhBx9oeobkxb1Z7axyzeQc1DtvRj0VgAuhA-lh-Q)

The only field that will come into play for our virus is the **DTA**, which we‚Äôll talk about soon. Further information about this can be read in pages 25-26 in the Giant black book.

So, let‚Äôs get back to our code.

![437x622](https://lh6.googleusercontent.com/lehxAL9VoN4pySWlvZEtdoOie5zKCOdpt5TxHJAFBs8_68sTNAJkxlh3-049I--_cp3QZKjryzKxk_cYAxYqA-4Klp6DhNoNxAbJCC3zcbkaG-k_ptAMgY4LZDuu3KYX2j3VB-gs9DQvwi6b1g)

Its well documented but to ease your understanding I will go line by line with you.

First at line 6 the address of the file name to search is passed into **EDX**. Then **AH** with **E4h** is setup to call **DOS** **API** service **INT 21h**. 

![525x115](https://lh5.googleusercontent.com/q8lTdUWrn0_BfU-O1-EkgHXt2KhhUhkn9iND3_wnIvJn0g0nNjdZnzTcveVJNbRWfZwpDRIBiGtn9FqaocZX1IJb30wEIOjTd9xr0vzGWYHt5sbWgIwAg0p0ESIHCpdttAMq9l27Vp5Hw56qrQ)

So, what does this execute? If a file is found, the **AX** register returns 0 and 43 bytes of the **DTA** field in the **PSP** are filled with data regarding the first file that was found (Its attributes, its size, its time of creation and Its name). If the service routine failed, the **CF** flag would be set and a JC is performed to line 47, which terminates the program.

Then on line 15 **DX** is filled with the address of the file name string returned in the **DTA**. **AH** is filled with **3Dh** which will instruct **INT 21h** service routine to open a file handle( A file handle can be seen as an abstract pointer to a resource, it used by the **OS** to access system resources)  and **AL** will be filled with 02h which will open the file for **READ/WRITE** operations. **INT 21h** is invoked again.

![501x110](https://lh5.googleusercontent.com/xnFmKEJ09ui_FSZkz6_jXtpa5SrtLcxvrpoQgdq8Vaw_cZSY6xtqRRlCMPq4b8s6T6AFcp8_AmENdqCVC1dzwxSS8TbyEWf3G1RM1e5mgAQkda_Qd0niw_kES3j-Lc0zDE47jwJMYIUzjbMThw)

![218x77](https://lh4.googleusercontent.com/T4KjlVcwjwRmO947xQ_6Uv-1pjUflBem9Y7Qqo5hCE0vFF7ZEDAuuuI7WTTr231j9ngga6cZJ0diocL3nxTvrKH-x1lfnmvVy0vAy_BgIcj_egNaFTCB6XHxJkuzsFwhnMAPBn5tn4pEHQDo_A)

If the call fails, the program jumps to **NEXT_MATCH** which will be discussed shortly.

If the call executed correctly, the file handle returned will be passed into **BX**. **DX** will be filled with the offset of the writing position, It points to 100h which is the start of our own code.(Remember that **COM** files start execution at **100h**), **CX** is filled with the size of our code(51 bytes or 33h). **AH** is filled with 40h which sets up **INT 21h** to execute a write file service. 

If this instruction returns successfully, the found **COM** file will be infected. At line 37, the file handle is closed. At line 42, the virus will execute service 4Fh which will look for another file, if this check fails the virus will terminate, if it succeeds the program will infect another file.

![513x119](https://lh6.googleusercontent.com/EAgrwdIiAi1DZKaWjRxfcPFoTv3x5KrciYBEEd32SHl34h4l-Mo2gNFbv0n7Z_oxWjssfs4dJPPETvJ8AUJZihQz3EwBGLtansXeCp44sckHqP-hoaS9Zyus4YvNoc_n70hsyusgyyHGXY9TNw)

To create our virus let‚Äôs first make a new directory using ‚Äú**mkdir**‚Äù and call it **COMDIR**, then use cd **COMDIR** to enter it.

Now execute ‚Äú**edit**‚Äù and write down the virus inside manually, use the mouse the navigate to the file tab and click new. I still can‚Äôt understand how to copy from host machine and paste into **FreeDOS** yet so if anyone knows feel free to update me on that. 

When you are done writing down the virus navigate to the file tab and save the assembly file as virus.asm.

![624x339](https://i.gyazo.com/260424c713aaf162e51f99616d57f450.gif)

To assemble this file using **NASM** write down ‚Äú**nasm virus.asm -fbin -o virus.com**‚Äù and this will create the virus com file for us. 

***

## <span style="text-decoration:underline;">Writing a Host COM application</span>

We need a host for our virus, I think a great candidate would be the code snippet in page 23 in our book.

![443x257](https://lh3.googleusercontent.com/GRJdOKrVxVsCkLowxsHes5UUfE7O4q7tErbTMpN48XkB7lB4H4hVB0D5CVeDnVCcCcRWJpovHwss6iNIcGrlmB5Ez18nXg8JzG8PQVlcinBiBKxnEAI2oJbrM-gzRKOdtlTeDkDTBKDd7twXwQ)

The program is very simple, first it prepares the message display routine by loading **AH** with 9. Then it passes the start address of the message we want to display into **DX** (Messages that are displayed into terminal must be terminated with **‚Äò$‚Äô**), finally the program terminates by passing **4c00h** into **AX** and then calling **INT 21h**.

I execute the ‚Äú**DIR**‚Äù command to display what is in my current directory, assemble our host program and check out of its working:

![445x295](https://lh5.googleusercontent.com/0MebiyFoPJWRem7HfSsu85tsOOY7y2OFTwc9BJo-MQzeHzAjiGwVox4dmhKaZ6eBVi1sGQ5PYrgfgkVVyOzXjNdWrPhn9fr3oFW46aKqouiiq40k5kgHtn3OeBylshIgaC94qkvVWRVFn1lfiQ)

Cool, lets make a few copies of it by using ‚Äú**COPY**‚Äù:

![445x43](https://lh6.googleusercontent.com/gS4XAmoy0vBljXKFbTNb3SbCxX3Za8U6ynPcMBAu_pyK6voaeeW_oSbzMF8yiWONFPDmuZjAeihOK_846foy_E0ZLglHTwoBwy6seNDBn0YaeZ2jxceSQ0gfFeb5weUuDwr4og7dvfpVd0tCpQ)

So now we‚Äôll have:



1. **HOST.COM**
2. **HOST_1.COM**
3. **HOST_2.COM**
4. **VIRUS.COM**

![363x146](https://lh5.googleusercontent.com/Ioci5xOaKBYpLcRPv_z51SF3CwQ0TEiSSNH_JpZzVpuNt38EnPIV1mvYmfHUIsz0LgTyUE7t_f-dzutrAJ3iauwbK8Mpq_2tR6TguCJbIDRq7GN8jYBQTmDHu0bd2zkA7bXqYTA32LyAIct8_g)

Now let‚Äôs execute our virus with the **debug** utility and see what happens (You can use ‚Äò?‚Äô any time to see the help menu of debug):

![424x25](https://lh5.googleusercontent.com/ulUFz6MfCk7Warmk75AhU4EIzptTWd-REFO7wWoCpvb6Ss24H_euxy6OrfdXJtqhiw6jtdk-Tv-GuejSBSprEE6x_ZTwstXWN1QlUtj9kvI3xizCZcO-zmPv0j5poBHQC-_BczUICEjChI0V3A)

Enter **‚Äòp &lt;number of lines>‚Äô** to execute lines of code

![429x128](https://lh5.googleusercontent.com/RW-bGCA43XjInH3LT1WgOPCLaFF1IMIy6fy_Oh1PumVo_5tD5CHcEXn7OyTjSISR3__8b5Tc5l3etQv7VgQlX-l1UL2TLx_9R8l3sbWQyV4unPSkSUXvrrKS4Oo0qBgx-WISzCqOmeIPVWn9vw)

First we execute lines 11-15 to execute the dos ‚Äú**Search First**‚Äù function to find the first com file, as we recall it should load the file attributes into the **PSP** which can be found at offset 80h. After the call to **INT 21h** service routine we should see the DTA  inside offset 80h from the start of the code segment in memory. Let‚Äôs dump the code segment at offset 80h ‚Äú**d(ump) cs:80**‚Äù 

![552x55](https://lh4.googleusercontent.com/hxNRz0nsKSxNzBp5nCUPYhwt8roO5zhZ1j4xTR4QRHZXbQa7sWCAVJDykfz8nVJgSPJLRMPQP5x0Eu1Mlbh59GBY-QO06gs_lt79reJsakYG3DhCdF8CKalgfajtRdv7q3yEfrsj)

The virus found itself! That‚Äôs alright though because we are just going to overwrite the virus with the virus!

Next we execute line 19 ‚Äì 26 to open the file handle to the found file, the file handle is passed to **AX** if the call to **INT 21h** service routine will return successful.

![445x160](https://lh3.googleusercontent.com/XdvWVP0I0eOdjvRNKcer6WSngZS1Co69_6K_EdjFfM3mOLyp89PJlgr_joPZL2IZ29fpgMox6kj84dWXzm4Tt4DTR85sNryjJyagRb6kKmjA1773T9xvcb8_s_2XeltBBZbm-5GydubrrDUmuw)

**AX** holds the file handle, lets execute line 30-37:

![560x299](https://lh4.googleusercontent.com/XYridebHd8YkY_NK3o_EUtdTMDfrotvIK5pj3U_0Ezb369mD-_oEi4qgiAtGBjX2oKgc6Zqmeou4i36k5yIZXIVO5XdjwboUCViSoHpemCMXRkIc9H54NzPA7lG9i-rFJFhGg__2)

**AX** returned **33h**, which is the number of bytes (in hex) written to the file. Basically, at this point we have overwritten the original file or the virus with the virus itself.

Now let‚Äôs close the handle, execute the ‚Äú**Search Next**‚Äù service routine and view the **DTA** field in the **PSP** again to see if it will find the next file:

![576x86](https://lh5.googleusercontent.com/pw-eR1-aPLz2kg4vQjWedx4ux3ZSqsQSzIxKGX8J1Sunt9zbAnhObFhPFKEX30T_Nut_8mfYnF4Q3Vzi3geh2XQBXTgHd3N4v7TQYN9_mlm3_hz-m83ZDB9fsqa_MhdoUwRJkFim)

We can see that it found **HOST.COM**, this exact operation will run until all files in the directory are overwritten. Let‚Äôs enter the ‚Äúq(uit)‚Äù command and run the virus simply by typing its name in the command prompt.

![476x313](https://lh3.googleusercontent.com/G3XhDfaSPed7zoIvKZ6yn_6Od8bPC9-hmg92CeRUhOer5id_wOdxeFVOihYseufT89a-xZpes-_yAPPYjtVOgGmfu0dwuj4LQASxoVe4YzPc_9V12oQUMqitbbVwoXfC93LldtFL1-KXKue95w)

Our host files have all been infected by the virus, how do we know? They all match its size and if we‚Äôll execute them nothing will happen. Pretty cool huh!

![433x284](https://lh4.googleusercontent.com/KEJ1uhmxDUvhdCT2gSe1BksUCVQpvFuDunZnJ_P-qE7BpANfJQrDWvi4CygiEIHuX8nYGtsZyxIUHmsRUtbrA_mvjs7iuxFJdLPZdDKyrg-3JBy_OACS_B3Rq04I7nfnDe7a-L7iqZdSY1pT6g)

Now that we understood how basic **COM** infectors were made back in **DOS**, we can attempt to make our own infector in Windows!

***

## <span style="text-decoration:underline;">Windows Internals</span>

To cope with the massive security problems that real mode introduced most operating systems today are executing in Protected Mode. 

**<span style="text-decoration:underline;">Windows Internals Basics</span>**

Here I will be explaining the BARE basics of Windows running in protected mode, some of the explanation has been simplified for the readers understanding. If one wants to expand on the information written here, please visit the [article listed above](https://www.codeproject.com/Articles/1273844/The-Intel-Assembly-Manual-3).

Protected mode is a whole new architecture and is beyond the scope of this post. I will cover only what is relevant to us under Windows. If the reader is interested to learn more, please reference the [article listed above](https://www.codeproject.com/Articles/1273844/The-Intel-Assembly-Manual-3).

The executing environment for applications is separated from the operating system, applications are separated in what is called user space and the Windows kernel is executing in kernel space. Only the kernel has access to physical memory and system resource.

How does Windows manage to perform this separation? It uses what is called Virtual Memory which is provided by the Memory Management Unit(MMU) chip in the CPU. The **MMU** separates the entire physical memory to Pages, these pages are handled by a special table, each page usually references 4 kilobytes of physical memory. 

When a process executes in a 32-bit Windows environment it has pages reserved to it in the Page Table. The process has no idea it‚Äôs executing itself with in the context of these pages, in fact the process has access to all 4 gigabytes of RAM in a linear address as far as its concerned. It assumes it‚Äôs the only process running within Windows and it also assumes it has access to the entire memory within the system. 

This happens to each process executing in Windows, so say we have 2 instances of notepad.exe running at the same time: **notepad_proc_1** and **notepad_proc_2**. If **notepad_proc_1** is attempting to access the value in address **0x1234** of itself and **notepad_proc_2** is attempting to access the value in address **0x1234** of itself, they would probably both accesses completely two different values. But how could this be? Well, it‚Äôs because they are executing in different pages in the page table. 

![624x358](https://lh6.googleusercontent.com/2JLLIHV6qHZSy5Kto_lGxmv3FL5xwo87kAmBKzFFDkuR_DmCzbnl1Z3QrJQHCPrAXlBBJGqQyEGUXCwTUixIs-O9KcEf3B_2gBiNR4IQYm9929Ln6KjUE7Z2-m4hStq9pKpJttgJVYjjyxA1Bg)

As can be seen in the graph above, both values are mapped to two different pages and these pages are pointing to different areas in physical memory. So, process executing in Windows running in Protected mode cannot touch or overwrite each other in memory so they can both execute gracefully within the same environment. 

But how do they have access to system resources if they are separated from the system itself? If these two notepad process are separated entirely from the system how can they open files? Ah good question! They are managed by the Windows Kernel. The windows kernel is a separate process running on windows it‚Äôs mapped into each process running on the system, the kernel is the operating system manager. As I mentioned before only the kernel has access to system resources and the system physical memory so if the process wants to access system resources it must perform a request to the kernel. This is done through API calls, much like the **INT 21h** interrupt service routine. How ever in **DOS** a program could use the **DOS** interrupt services if it wanted to access system resources in memory, but it was optional, nothing stopped from a DOS application from performing manipulations on system resources, it just was very uncomfortable. In Windows, a running application **MUST** call Windows API to gain access or to modify system resources. 

So, our graph looks like this:

![624x411](https://lh4.googleusercontent.com/nr_XkF0rTbIEWRxiBzajc6k39nt5HLrrLJAUHdAt-KCY6tM1Mn7TWGB06VfIrtLcL1Q7zyWuiIsIYj9qwOWFfKABw-tE9BLzM4wMKSKj2EbvDoM_DnNKu3MamGW3TyFmIue-xxWU5a3ABmal8g)

If the kernel doesn‚Äôt see these request fit, it will deny the process access to the system resource. For example, say **notepad_proc_2** is currently reading **README.TXT** but another application wishes to delete it.  The application will invoke **DeleteFile** API, this API will pass into the kernel, the kernel will see that the file is currently being read and will deny the application from deleting it.

This mechanism replaces the **IVT** and creates a separation between applications and the system. The applications cannot do anything they want, they are separated from the system and each other and basically can co-exist with no problem.

Alright, now another question arises. I‚Äôve claimed that each process has access to 4 gigabytes of memory, but in a 32-bit system there are only 4 gigabytes of RAM, how is this possible? Wont the system fault and crash as soon as an application overruns the entire RAM?

The answer to that is simple, first yes it might happen that a program (say a virus) will request so much memory that other applications simply couldn‚Äôt run. To solve this problem Windows performs something called ‚ÄúPaging‚Äù, Paging is an act of taking a page and mapping it on disk. Instead of managing all the pages in RAM, some pages are put on disk and managed through there. Access to these pages on disk is much slower and can cause some applications or the system to start slugging. Paging is also used to free some memory from the ram. Say an application would go idle and would stop using the RAM. Windows would detect this and to free temporary memory it would save the applications pages and map them to disk, when the application would run again ‚Äì Windows would map the page back into RAM. 

Alright bear with me guys, just a little more theory and we start developing again.

Where is user space in the process and is the kernel space mapped into the process? 

The kernel space is mapped into each process and the user space is where code, data and the resource of the application are located. It makes sense to map the kernel into each process so it would be easier to perform requests to it.

The user space is located at address **0x00000000-0x7FFFFFFF** and the kernel space is mapped from **0x80000000-0xFFFFFFFF**. The kernel gets 2gb and the user gets 2gb of RAM. So, its fair game. 

***

## <span style="text-decoration:underline;">Portable Executable (PE) File Format</span>

It‚Äôs time to code our virus, it would be a simple virus much like the COM infector. Infecting only the files in the current directory, not employing stealth or direct system calls. But what kind of files are executable within the Windows operating system? These are the **Portable Executable** files and they have a much more complex file format than the COM file.

Since it‚Äôs going to be a basic overwriting virus affecting only PE files, all we need to do is overwrite the code located within the PE. But the PE file format is nothing like the COM file format. It has been discussed a million times on the internet, but I truly believe that one who knows the PE file format by hand can only leverage from, especially when it comes to malware analysis. 

As far as the basics concerned the PE File contains:

1.  the PE Headers which contain various information about the file
2.  4 additional sections (sometimes more)

    **The .text section** ‚Äì The user code executes in this section

    **The .data section** ‚Äì Initialized global variables and data for the user code is stored here

    **The .bss section** ‚Äì Uninitialized global variables are stored here

    **The .reloc section** ‚Äì The relocation table is stored here, it is a mechanism that allows the Windows PE loader to load the executing PE in different areas in memory

Before we start destroying PE files let‚Äôs see how they work under the hood. Let‚Äôs start by trying to find the location of the user defined code stored within the PE. But finding it is not as easy as one might think ‚Äì thankfully the PE header is constructed in such a way that is relatively easy to find all the fields we are looking for and we are looking for a very special field located inside the PE header called **‚ÄúAddress of Entry Point‚Äù** which is the offset of the location of the user code in relation to the base of the file.

To experiment with this, lets code a host file in assembly in **MASM** that would display a message when run, Open Visual MASM  -> Click File -> New Project -> **Windows 32 MessageBox application** -> Save Project As in your specified folder. Now let‚Äôs examine the code:

![528x525](https://lh3.googleusercontent.com/kuO_KOBoRgGPPh4Mw5KIWK1eW_4osgCU9_fz2-C53VZSvaW9b9A2qiNPRdF6Y18aUMi2YUpNQiKi0Vcn2jkOaNgjlJdR_orAikzWMRzTE6_ZyVUoJYWMVgyQd1ALglQK3bUdc0geVlaTLc1-vw)

In lines 7-9 we define the model of the assembly binary (We‚Äôll touch this on later chapters). Then on line 4-6 we use the ‚Äú**Include**‚Äù directive to instruct MASM to import all the constant types from **windows.inc, user32.inc and kernel32.inc**. These constants stored in these files define various constant parameters for functions (e.g. **MB_OK** constant for **MessageBox** API which will spawn a message box dialog type of ‚ÄúOK‚Äù)

Then in lines 21-22 we include all the assembly functions definitions for **user32.lib** and **kernel32.lib** which define various Windows API calls. Then on line 27-29 we define the PEs **.data** section and as you recall it should contain initialized global data. 

Then on line 34-41 we define the programs **.code** section which is the section that contains the code of the program. But wait Danus! Shouldn‚Äôt the **.text** section contain the code of the program in the PE? Well yes but in MASM due to compatibility reasons I guess(?) They kept the name **.code** instead of **.text.** 

We then define a new ‚ÄúStart‚Äù label and call **[MessageBox](https://docs.microsoft.com/en-us/windows/win32/api/winuser/nf-winuser-messagebox)** which is defined by the Windows API as:

![235x170](https://lh6.googleusercontent.com/nJP4ogjOeuHhFdmu7fyf1E3MDK5rhXuITCaxWV7AjLVE_QVKmWp1vRKxfaSnNuP6-z6iFR1LL5SSEGgjB6MwWAmSY3MWVqmiRnCNMT9mWQXCTQmHGHPESdIlkxfUSHoIWiIqwZQ5fkSRXzDy9w)

In our code we can see that the parameters are passed as following:

*   **0** ‚Äì handle to owner of the window of the message box created. **NULL**(0) parameter indicates that there is no owner meaning the message box will simply display independently
*   **ADDR strMessage** ‚Äì The address of the string which will be display inside the message box
*   **ADDR strTitle** ‚Äì The address of the string which will display the title of the message box
*   **MB_OK** ‚Äì A constant included in **user32.inc** which indicates the type of the message box

**[ExitProcess](https://docs.microsoft.com/en-us/windows/win32/api/processthreadsapi/nf-processthreadsapi-exitprocess)** is then called which is a Windows API that will terminate the process. It only has one parameter passed to it, in this case 0 which will the process was terminated with no errors. 

You can notice that instead of using ‚Äú**Call**‚Äù, MASM uses ‚Äú**Invoke**‚Äù. You can still use **call** but **Invoke** is a MASM assembly macro that makes it a bit more comfortable for the user to call a Windows API function. 

Let‚Äôs change it the **Invoke** to a **call** because assembly pros like us only use native assembly. I assume the reader knows assembly but just in case you don‚Äôt ‚Äì remember that function parameters when passed in assembly are passed into the stack which is a **First in First Out data** structure. so, the last parameter is pushed first, and the first parameter is pushed last. If you want to expand on this information please [read this](https://en.wikibooks.org/wiki/X86_Disassembly/Functions_and_Stack_Frames). As an exercise, try to do this yourself before you read the solution.

![419x354](https://lh5.googleusercontent.com/wpdgCJRbtOnHgDUO-XI2PulwOJrXvZ4WH8mrm51H7cWq4p2ri2VQ3rjFqAZOlpD9CTaZZ_RWT7f_422Zt2ycIK_JsD_aT03RWmiEob-_NnZEJHGr9O9zjoe68_NiEhlLq3GsGA1fsZf3rYiOLA)

So, if you did try to do it yourself and failed - you cannot use the **ADDR** keyword in push instructions. You must load the address of the strings manually into registers and push them into the stack.

![148x160](https://lh3.googleusercontent.com/E2QtUBH8Vu36hQXaQM2cyLf2Hs2FDSq8HOK9ac9Zu6Q9qg-UPmGxIA7oF-wBoUd7-02GRpaa5f5wH4Mga9-EeiKD-FnADi_wyegQm7r7LDjVaARyLQjX08o-h-Bpbh_g4wq0TKSZPhAOB_C_wg)

It works! But the final binary is big as compared to the **COM** file we produced for **DOS**(3584 bytes vs 51 bytes.

![624x24](https://lh5.googleusercontent.com/wz08alagaBRuoZn1ofMUrYAdr9Z_c0c8kpaki-9At6jxp5GtDYyhzjdXVqUshznQjopNW69_7e7lRBOwIXbXawWUP0jIiS3M_LVv7uhekn9pNX5fXMTdl5-6rtdIMfqNiwbwCwoKpP3nLUHUTA)

It does make sense though as when we are using the ‚Äú**Include**‚Äù Directive we are including all the code that is included inside the libraries we are importing. This can be fixed using DLLs which are loaded dynamically into the PE, but we‚Äôll touch that subject on a later post.

Now let‚Äôs examine the PE File format with **PEBear**! **PEBear** Allows us to traverse around the PE file and view its entire structure so open **PEBear** and load our program into it.

![624x265](https://lh4.googleusercontent.com/axBjcHOZ5JeGHrrJWTegfJcPvZaRjgNpRdOA0zV4mwtwJbt-gUgbW6GPIO5530jawjuYQROHMZwXmb0NOQu0le-7znEg0B2r-3_mzc9dm78sEo_Ou_aLdQ5ZvbuGCl3qGdN-UZr2TAdwh6JCDg)

I‚Äôm going to use this **[PE File Format poster by OpenRCE](http://www.openrce.org/reference_library/files/reference/PE%20Format.pdf)**. It‚Äôs going to help us follow the PE structure, so I highly encourage you to use it with me. The PE File format can be viewed as a large linear structure which contains a lot of sub structures, this helped me a lot when I was first learning to traverse around it. Almost all values in each structure are simply a **Relative** **Virtual Address (RVA)** offset from the begging of the file to another location within the structure. What is RVA? Soon I‚Äôll explain.

You can view fields and structures inside **PEBear** using the left menu list which will redirect you to the location of the fields inside the blue **hex dump** 

![259x315](https://lh3.googleusercontent.com/LwenfpM1VsGFZwiFonUVgIHE7xS5wyZ2dyM2QgF2jZbcdAgF2TQUXiS7TZmMn_kvOaiowoz8cI3RdwTZShpnvBwNjtAxumEjtlCzRRbWcLYsl7u3SUZqGEyJ3orHwaoU_rAe40a0V7ZeXcIfBA)

and you can use the middle tabs that can simply list the PE values in a more comfortable fashion.

![624x39](https://lh4.googleusercontent.com/1GnnCAkaZZAijQC3Oiw5Pi4dnMOeuu7rTVUBi5Fnhn1OBt3EFdG3GAIRdm9GTKXuuGiXss8k77WAfQyPBKAJQ_lix9Xh_cGxKO-PSIZi5KjwC4JwkeYGQZrM_5SA0nKtVgjBOS_TWceg1wzifQ)

Let‚Äôs examine the first structure of the PE File header the **DOS HEADER**:

![624x216](https://lh4.googleusercontent.com/yUraX-idhNLWmaWBHQKvnbQBtT2XvNbmI3uXMrohsR85uQEaJ0GzSfVvljnlVl_NwbYcA89SJ6cD8VsfNU3qLfN9jiL2Bk7_GxdmDkw-GkeXjb9Y6DMDRqtcFJMeRWGXWnjkwb_DBmkrKstM3Q)

And the OpenRCE poster:
![190x283](https://lh3.googleusercontent.com/YwQ_2Wt343O9S_cDmrHJaXApQDyYh791oPt_PAx0UbOnDANwEROGF75_Ggu-FFqYyLih1RwUF8t8zsi0b2uKv4j9wP8GQiPOEci88aNfEutxamGvYAljhdLygwI1PCDZXIkxVOWrQZWfZdZuYw)

There are a lot of values here, but we only care about two:

1. **e_magic** - which is a two byte(word) value which contains the letters ‚Äú**MZ**‚Äù, it‚Äôs the PE file signature and you can find it in all PE files. If you‚Äôll look at **PEBear** you can view it in the hex dump as well: \

![624x149](https://lh6.googleusercontent.com/8GjAiy2ZjzUcS3y370PEfoWuZzzZLyHJ424SGF9sqKoCVX6xyBPgHt6n3TjwYgxxPtmE0O8LgHt1ImyGcdu0BtWNsHu0y91uU9GqVMMbALUIcjGoD03sSXKbiOnrKM1YOLFg6hLjBt8U-qFnWg)

2. **e_lfanew ‚Äì** contains an **RVA** offset value to the location **NT_HEADERS** structure. \
So what is RVA?   \
Well, when we are viewing the file on disk much like right now, when it‚Äôs not loaded in memory all offsets are relative to the start address of the file ‚Äì when it‚Äôs viewed on disk the files base address is zero. When the file is loaded into memory its going to be loaded at a specific address which is not known until the file is loaded into memory. To access specific fields within the PE values, we use the RVA to calculate the actual location of those fields or **the Virtual Address (VA)** of the fields. The formula to calculate the actual location of these fields goes as follows: \
Virtual Address (VA) = RVA + **Base Of Image**

    **Base Of Image** can be any address, it doesn‚Äôt matter. When are traversing the file when its not loaded into memory and its on disk the base address is zero.

3. **DOS Stub**, which contains a small program that will execute on DOS if we attempt to run this PE inside of it. It would simply output ‚Äú**This program cannot be run on DOS mode**‚Äù. We can copy the hex dump marked in blue from offset **0x40** ‚Äì **0x70** and disassemble the code(You can actually run it inside DOS üòä) 

![297x203](https://lh4.googleusercontent.com/mwxtHdZsQtUDRtKoD6jzrEDZxL-1i7dcQkJAZk6tsIbcI-OK0nZ6n2l7PEOnKmcaHervKLT0iA-JnVotLST-cDFsuHfr6nNeaeN74_RTqWZl0v4_Li1ADLOyaVAM4nWm6NRo4Zxv4gbFfv2lAw)

Armed with this information lets try to find the starting location of **NT_HEADERS** structure which is found inside **e_lfanew **field within the** DOS HEADER.**

![484x485](https://lh5.googleusercontent.com/DUbXY9_nJNulC0XkvzufwmkwQPtIZ1nId_CtYg0x89KlhvtvtuyuvT25DbPCpYtMBtrXBoL2BxER0k8yUhA-AflqXJQPaMkcG56RHlupQz8n4_r794_Tkfrq8hTw2M0-F9zsOY_IMPOz2min6w)

So the location of the **NT_HEADERS**(also the new header) can be found at RVA 0xC0. Easy enough right? **0 + 0xC0 = 0xC0**. 

What if the computer loaded our file at address **0x412000**?

Simple! To find the **NT_HEADERS** first we must find **e_lfanew** value. We know its located at RVA **0x3C** to the start address of the file. Let‚Äôs calculate the **Virtual Address** of that:

**0x412000 + 0x3C = 0x41203C**. Now at this location we find the value **0xC0** which is the start address of **NT_HEADERS**. Let‚Äôs fine this header start address:

**0x412000 + 0xC0 = 0x4120C0**. 

Next, click on ‚Äú**Go to RVA**‚Äù

![495x307](https://lh3.googleusercontent.com/83ACE4toDaLgoPN3xymt2tobjnPPk1WGqMw9ONBQd-bGwhe9kVUzG2adjL8uyYsMIDzp2hppMohJOIliqZqLBvOo1d5H7w8mFmip5qbU9wYd7_NNLWNOSA2bmhais-STDwg6I8YrDXLVnUUIhQ)

Enter **0xC0** and click OK.

![226x171](https://lh3.googleusercontent.com/4SgGylIDWXowrT38PYtEesJknynnOJiWK-l7bKqo6UZ8pi1CjLDo4wspffmn57I53YHW_QcAoRrN6QL4N-vRrVzbDROV0AkbZiAwCdKh5-1ZXo2Nckd1q7tz_Tg-CdEtL4cokXKPRzuCGXLb2g)

We land at location **0xC0**:

![408x209](https://lh5.googleusercontent.com/o0nwX4o3sZe3Nd_9TdTlwEqbeVkT2gd8cFjD9WqFHNrEvDgBY8VsXDB1-t2L8cfCmujTvlkllyYC5o4eFzMatSD6_yOFql-QpVpfZtNhnHfQBRcyU6B7hYMLnticSPJKcxvJtkW79n1fPilLZA)

Now to confirm we actually landed at **NT_Headers **click on **NT_HEADERS** on the left list. By click it ‚Äì it should take us to the starting location of **NT_HEADERS** and it takes us to the same place, as the Hex dump didn‚Äôt change.

The **NT_HEADERS** contains 3 important values:

1. **Signature** ‚Äì Will always contain **0x5045** which in ASCII translates to **‚ÄúPE‚Äù** 
2. **FileHeader** ‚Äì A linear address containing **FILE_HEADER** structure
3. **OptionalHeader** ‚Äì A linear address containing of **OPTIONAL_HEADER** structure

![367x88](https://lh5.googleusercontent.com/PkJ1WRxcYXmBun3i9-K7OdsYyxHMuRajq8GaKd0-k-JTjFFyEcHf3wOjY1gmHVx3DCLYcTfP_6_PoduD-pv3THWfloAdV33xBVJHKRDmSUcnRSXoQ4v33VIbPBnegrWnn8CEh64LTqY8feB_ow)

The File Header is an interseting structure which contains very important information about the file itself such as it‚Äôs CPU architecture(**Machine** field) or an indication if the file executing is a 64 bit file or a 32 bit file (**Characteristics** field). But we seek two values located inside the **OPTIONAL_HEADER**.

![355x435](https://lh6.googleusercontent.com/xrulGGlyD9WPY8k-Ry8_bNf2kZ62LZn5NtzXhfuhUR_KB5o1Gw1hadqy6Idr3PQyehEQFQtTZxNoevPanlrMIgnsZM6iR3vWwD7-WHcd2mrGkBkmj0hrE_PFWgfIKCguEP6-V0_sBzNJAvFfiw)

We seek the field called **ImageBase **and** AddressOfEntryPoint**! 

Alright so let‚Äôs find the **Optional_Header**. We know it starts at **0x18** according to the NT_HEADERS specification(refer to above image) and its location is relative to **NT_HEADERS**. **NT_HEADERS** starts at **RVA 0xC0.** So, to find **Optional_Header** we simply need to add **0x18** to **0xC0**:

VA of Optional Header = **ImageBase** + **Offset of NT_HEADERS(0xC0)** + **Offset of OPTIONAL_HEADER** = **0 + 0xC0 + 0x18 = 0xD8.**

![624x220](https://lh5.googleusercontent.com/UfU0q4IN189VonctulUtmQfwBLcWKf3D4pEBcogKsspZ0g5I7CDNoQgxS3077rvuAV0Vmz3MmCp06BkgzD1b7yHgE6PBS2PckS0d5S3gcDk1ttd3lxmGalikJWDtoiqdFioU63KV)

We are correct! Now let‚Äôs look at the values inside the header using ‚Äú**Optional hdr**‚Äù tab:

![624x434](https://lh5.googleusercontent.com/QpIjSlzUcDbEz1i35zLTZAlgYfFVS17iboe07UaSK9o0i08OlShGt9_Mr_Hdperag8G4YpI0mZdOVdy-TncfE-r7Jq-9l0_9bV0qByv2vJExE01MJK6BEdl7O5Lx8o8nIQPzbym3LL1UVJbcdg)

The **Entry Point** field value contains the RVA of where the code starts to execute with in the file. 

The **Image Base** value contains the location in which the file will be loaded in **Virtual Memory**. The default value is always **0x400000** but it due to a mechanism in Windows called **[Address Space Layout Randomization(ASLR)](https://en.wikipedia.org/wiki/Address_space_layout_randomization)** this value always changes on run time. So, the start address of the PE is almost never known unless **ASLR** is disabled for the file.

Armed with this knowledge, we can open our file at any disassembler. I‚Äôll be using Cutter( shout out to [@megabeets_](https://twitter.com/megabeets_?lang=he)). Cutter is a free disassembler and debugger based on **[radare2](https://rada.re/n/)** so everyone can use it üòä

![582x398](https://lh5.googleusercontent.com/jU6vKLR2DNBc-H5cPV-Wwk22ks7BP07VUo1RwG9IQAszvGHWlXhuV0N7eMahKIhjYV5MwD_ONY_i0KKCrZHihn5mRxJliwUGShM_kki_M-MADmdree3xRal129AwsciYEsIbdqxq4quGlM8jzw)

I will be loading the file with ‚Äú**Virtual Addressing**‚Äù which will load the file with the default Image Base.
As it can be seen:

![585x93](https://lh5.googleusercontent.com/LKjdtBfAPIIsUsQqiZFcGzwtzEYhhvFAH2Q_RiMvrxSVDt_Vl9zm1Ucdvkakz7vjw6q3UubbrsSb_VzFXIRYLXlTK2xphzlwgN_cSqHSMg1XqgvZ9769G_mwCDT_LyTlM4xzqxxJtdfj0S6zZg)

**Entry0** is located at offset **0x401000**. As we recall the RVA of the entry point is **0x1000**. The Image base when loaded into memory is **0x400000**.

**VA of entry point = Image Base(0x400000) + Entry Point(0x1000) = 0x401000**

If we double click **entry0**, we‚Äôll land right at the entry point and we can see our code even labled as **.section text**!

![624x180](https://lh3.googleusercontent.com/t2oHxsyF1KvesqwHebcFjUBbiWSuVo4qTljE2ztsSxnLXA6Cba84oAGbTCY8QG5FrBrC0pSpS3JNSUrNPsJJ5F8BtoXlkRVPUit_3M9-O7FVgYD7TFhDRzgMSKZluq2czhAAQVR8P0E3rOpmEg)

A funny thing I noticed ‚Äì we can see how MASM assembled our code. It seems that instead of calling **MessageBox** directly, MASM chose to execute a call at **0x401012** to jump to **0x40101e** and from there jump to **MessageBox**! 

Alright, lets summarize what we know:

1. We know the basics of how Windows handles memory and the kernel
2. We understand that PE files are more complicated than a simple COM file 
3. We know how to traverse around the PE file header using PEBear
4. We know how to find the Optional Header, and how to  use it to find the default virtual address of the file in memory and use it to find the start of the code of our file which is located inside address of entry point

***

## <span style="text-decoration:underline;">Building a PE File Infector</span>

To practice our new found knowledge, Lets create a simple overwriting virus, it would work much like the COM file infector:



1. Find a file in the current directory which contains ‚Äú**HOST**" in its file name
2. If file was found
    a. Overwrite the found file found file with the infector as it is on disk
    a. Find next file
        i. If file was found, execute 2 again
    c. If file was not found, end the program

3. Find the following of PE fields in the virus and print them:
        a. **e_magic** - DOS HEADER
        b. **e_flanew** - DOS HEADER
        c. **Signature** - NT HEADERS
        d. **Machine** - FILE HEADER
        e. **Magic** - OPTIONAL HEADER
        f. **Size Of Image** - OPTIONAL HEADER

4. End the program

Although our new found PE format knowledge wont be used directly for infection in this case, it would be used in the next chapter. This virus is not an advanced virus nor is it very stealthy, nor is it concerned with saving space or using local variables. It just destroys everything that comes in its path. 

Lets assume that all the host files to infect are located within the same directory including the virus.

![624x144](https://lh4.googleusercontent.com/zZRqOsHWT8ebY4ZZwiJnk8WijnNQRTBNbJqESer596lLCgkB-XQiH7dF8lFj_lxxodNxNdk8rBc64g03MGrByoxlNB9_AAZb-20z3Jq4HnmmUH5Jn3lrk4OXWddYnWelV-pGS54dZk1oWEAoIQ)

Now we have to discuss 2.a, how will we overwrite the host file? We can read the virus file when its loaded in memory from its ImageBase and dump the virtual memory to overwrite found host files. Alright this might work but the problem is that the way a PE file is mapped in memory is very much different than how it is mapped to disk, so if we overwrite the host files on disk with the virus in memory the infected host files will not execute. What else? Well we can open a handle to our virus ‚Äì read its code and then overwrite it the host file. Alright.. but one problem, if we execute **CreateFile** API from the virus **process** which will open a handle to the virus file on **disk** the kernel well deny that request. The reason for that would be that is that the virus **process** is currently opened from the virus **file** on disk and that is enough reason for the kernel to deny any process access to the virus file on disk, even for itself. 

Even though the kernel wouldn‚Äôt like the usage of **CreateFile** we can copy the virus file to the host locations. The copied file is the same virus file but it‚Äôs a new file with a different name and its unused so nothing is stopping us from opening a handle to it. Then we‚Äôll read the virus contents into a buffer, delete the copied virus and for each found file in the directory we‚Äôll simply overwrite it.

There are different ways in which we can read the contents of the copied virus file, but for simpliciteis sake lets simply use **GetFileSize** to get the size of the virus and **ReadFile** to read the files contents.

The next problem is that the virus cant infect itself because unlike DOS, Windows will not allow us to open a handle to the virus itself,  nor create another file with the same name as itself. To solve this we‚Äôll use **GetTickCount** which returns:

‚Äú**retrieves the number of milliseconds that have elapsed since the system was started, up to 49.7 days.**‚Äù

The value is returned to **EAX**. Well use this value as a name for our new copied virus file. Then to avoid opening a file handle to the virus itself we‚Äôll check if the found file name in the directory matches our virus name. To traverse all the files inside the directory we‚Äôll use **FindFirstFileA** and **FindNextFileA**. So, our result should be similar to the com file infector.

Source code can be found in [https://github.com/DanusMinimus/MalwareArt/tree/master](https://github.com/DanusMinimus/MalwareArt/tree/master) I would not list it here as it is to long. I encourage the reader to read up on the API calls and the PE Header values that I would list in my source, learning to google and to read up specific information is a very useful skill to have in reverse engineering and malware development üòä

Please load the virus in its assembled form into x64dbg and lets start executing. First we execute lines 63-89

![624x363](https://lh5.googleusercontent.com/euTx7pe4RdKvOdA92SHAditk0Xzb9Qs22xJliwcFgRQrEeK1u49uK00vvMfAKJd30hoe6mv1Yph-_s44PQFWG5CAwWA5T-GjVvxZI1tcZS-vUVY6AOXJGSX7fubxPT1c35S1ZF1KMtBaa9TFxw)

I invoke **GetModuleHandleA** with the NULL parameter, which returns the base address of the virus as it is loaded in memory. The value is saved inside the global variable **dwImageBase**.

Then I invoke **GetModuleFileNameA**, with a NULL parameter which would return the full path to the current executing process which is our virus. The path is saved inside lpcstrFileFullPathBuffer global variable. 

I invoke **GetTickCount** and use **sprintf** to generate a new file name and save it inside lpcstrFilePathBufferVirus. Then I use **CopyFileA** to copy the virus‚Äôs main binary to the hosts location with the new name. I then use **CreateFileA** to open a handle to the new copied virus with **GENERIC_READ** permissions. One might notice that I‚Äôm using CreateFileA instead of  CreateFileW, the difference between the **A** postfix and the **W** postfix is that the first expects a c string and the latter a wide character string. In a C string each character is one byte long and in a wide string each character is two bytes long.

Then I execute lines 90-112

![624x344](https://lh6.googleusercontent.com/wvQkjc_4orV947b_830-EpUW3YlleofW2H7McHCLV2ify9gqOmQhssE8ycnYrmBluej-rK60_UNf96t5AktLtZEJExK58HiyNhJu4v6TCpQiZ3NMPkOX9OdXi9ChYpxbwm_T8F5k4GKLhjY8RQ)

First I save the copied virus file handle to a global variable called **hSelfFileHandle**. I then invoke **GetFileSize** to get the file size of the virus on disk and save it inside **dwImageSize**. I use **VirtualAlloc** to allocate virtual memory inside the virus process which will hold the virus contents as they are on disk. I invoke **ReadFile** and read it entirely into the memory returned by **VirtualAlloc**. I then close the handle to the copied virus and delete it using **DeleteFileA**. 

![596x226](https://lh3.googleusercontent.com/6nc_T2biNLXGRyMqmYtPH5AjN6SZGrTAmk5r2n0vrmNeqVcRhBN_oo8LWLw-8k922eZwYeaYalgecOVPIUHOoh6xmQegVsPkuPjlYFqeawtPejO3MCsEp5wTx6ZKVL4osFezWvyDsKl3F8IN2Q)

The virus was loaded into memory! we recognize the ‚ÄúMZ‚Äù signature value and the DOS STUB string!

Next I execute lines 115-143

![434x446](https://lh5.googleusercontent.com/fV5P2SouJnCj27ROtAfRZtqoMgj-HQ6TpBEjZDg_xdYKAo2_0YkBI7iVyqkD8dnCUSISD5PF3YtejPbWx5RSte3frpUb9dIoC--P01n_Um00-IyIyW2iaC0nypD60vYrGHhyhilRNN_KfNRznQ)

I load the saved ImageBase address into **EAX** and print its contents which should print ‚ÄúMZ‚Äù

![539x311](https://lh3.googleusercontent.com/JWkc4DF4ZaN24W-GetWx0lQ6GOFKGlIHHbJzPYIFiERipQfBwLfcyq8ZH7Yu4JSKXD-x9PtdPx-je43XCIO9WwU6NV6w6SK7dBvkdFFjOAEJCSpDXWQyaPaoEtUIXC_GKSAi6RyDpNHv0yov4w)

Then at line 120-125 I save the ImageBase inside **EAX** and **EBX**. I add **0x3c** to **EBX** which as we recall is the RVA to** e_flanew** field inside the **DOS HEADER**. This value contains the RVA of **NT HEADERS**

![624x72](https://lh6.googleusercontent.com/iOERqwhV_cw7EZkW6a5ASVuprfQIXegAyBMKDx-G1Ft1odp9LmS8-3UUDCoYEhCJAJfWdtMgP1dKA5-eJ9xapw7ueyjcHyAnLl1dCGypJC96O0yU6ifC4fwkixypgoGBcmAFRzXqN5R8lNXKzQ)

I extract the value and add it to **EAX** which should move EAX to point to the start address of the **NT HEADERS**. I then exchange the values of **EAX** and **EBX** as **EAX** will be modified inside **printf** and print the signature of the **NT HEADERS**

![473x117](https://lh3.googleusercontent.com/_5sUa5Lw6h76f3lveylgPixrfm4MIk-6yzOUTs0Sx6S_XfISrwhnzhkVxiCZPqfHzzkV1NP9AeSSfqTv10PhlCiqf1xZcT8eM1upzZ4L_AMMKCtcf5wk11_TBKjYnb34-ocYHzVzu8OxIZKHwg)

Then I execute lines 127-132

![519x139](https://lh3.googleusercontent.com/21X4hSEm1VJHW0mjzdXXryhpk6KGJyQYrzmPjAoZH42_32m98YLTjnRrQe7Mxj6OZpGunpdhRG_M8AY97UzUz6uVczhcNi4QmWRRqir79lx7c4CeWL1fEqlggb2gu7IxU7VEUUsITtOVuKAhmQ)

I move the **NT HEADERS** address into **EAX** again and add 4 to it, which should lead as to the RVA of **FILE HEADER** then I load the machine field value which is the first field inside the **NT HEADERS** field. The Machine value is only a WORD long(2 bytes) so we need to trim **EAX** so I pass **AX** into **CX** and print it

![427x104](https://lh5.googleusercontent.com/rzAf_uWiEbNbOEe4YC0OlEMKVQVFMq2DMjVam4VxVuR8vV8zqf7XrxLvktLuyZiAin3xf0c_dP0QPlhd4fNRSPc4sTiAWrsSuB5beAsO1fQLaEWTsIdcmkrsfLWv8pnW63ZLUsz92LBCWWKVdA)

**14c** is defined by Microsoft as an Intel 386 compatible executable, cool!

![624x52](https://lh5.googleusercontent.com/kHr0dXiQ1V6nyJs02T74_2TVUOl8u98wwjLIUBYtFy7VL1vMlc210JVBESxSNtdFMm_IvHhiJuHQx0mHxvHk7sBbNjjMaEHmjzPHZTS1uGEORvnO1qLLn5x7mIkst3f-7wx3xl2nQ6CjnnFEIw)

Then I execute lines 134-138

![501x107](https://lh6.googleusercontent.com/QkhC6QmxDHggejDgUuuvz9w7Xsb41IQN5MdRsJ9NeQOlgjY_H3W-B6or7CEjGq1YoZoB1WusSBe8ixhgpqD2SGhxcoVnUUCBcfUlt2gC6iT0Ecz4cTMuzLnL9y9Qi0-u4i_VmyTv0B7d39OJLg)

I add **0x18 **to **EBX** which would advance us to the RVA of **OPTIONAL HEADER** and I load the first field of it to **EAX**. Its only one WORD long again, so I perform the same trick I did before. One might ask why am I not just passing **CX**, That is because printf expects a **%d** which is a double word value. 

![444x130](https://lh5.googleusercontent.com/s7aUwlyslD-h9qQwZPoOelnDxgG57m_cmRpkl8Ta-RQboR-ORoQADQxnBRYk4fgxRwAh8UndkjnJ9WmyL3aiVwChJJfwtx3Ki2sMRdWOH9uRIQnwsAvg5y3OAGOsRhyGTlLWqJyk9BqB0-eI8Q)

What is **10b**?

![513x117](https://lh6.googleusercontent.com/Wzv2n7k3w12pvDBVSBBnVMQstdeP17en-dZzUnK0pc4Q6-qInT2Ii6Ct2URx0xnTLct-Q-gcXHUitARouyhBND_JRX5_6INH4dsZKlmtPI5cQgNVs8RtSVnt18o_uW3OE0EfO57X4Kjedo5nyA)

You can learn a lot from the Microsoft offical documentation.

Then I execute lines 140-143 

![506x89](https://lh6.googleusercontent.com/pe48e2mUX08RaKGyC0WZkBVtG5gjcbCOCHDfcDdQzSv77nSeB6iWvY3ysUD6BovgnNtRL4DoUnJ71nW7YTeAWksukbNFQ4ypB6HaWLrPaO7E_NIJvahqLNnUxulsDqkZnz9WQk9cUoQqmxlacw)

I advance **EBX** to the **SizeOfImage** field and save it. Please read on that value yourself. Notice that I first save the size of the virus file inside **EDI**, we'll see how this is utilized later.

Now the file infection begins at line 146-156

![571x156](https://lh5.googleusercontent.com/QvYQ5kZzX-aujqurTklaAkqAavg_KqyKdRHP_L5YmDltKKEXXt35AJxNxSmFt6q4i9g_73IBwzYD7WT3FL5-wRMkFuUSEQu9VRaKhtaKaaO8xVDpeovZ-B5sEEXF403tj6OBGWQ0bY2GNIw52Q)

I invoke **GetModuleFileName** again and save the current executing file name inside a global variable. Then at line 151 I invoke **FindFirstFileA** which should return a search handle to a file found by a specified search parameter

![624x20](https://lh6.googleusercontent.com/xTjNKBFc2DwxUtVq_5D8smwCq9dJBqZpXd6d0LxWijb5KJ1w8O2yuJvDITklTTsvkNU2MSMFZyQC7L-gnfVfqoHR9WddamlZWg-fXqZSmJsRVdFwpZngR6M1DLSMxesc0EbO8BYkbQnU94GrPQ)


Only file names that start with the string **HOST** inside a specifc directory, if the search handle is returned it is saved inside **hSearchHandle**, the handle is printed and then we jump to lines 164-186

![624x294](https://lh3.googleusercontent.com/9kMwgoz8Oe72YJlibMrXV2q4PSIy-KrclGPMOiu8glM6p7hJP58A9uDRZ4O82PdjNf4qQdteREZ5CgGgCrkEJ49htAybI5sE_u_wRaaK7slWRr7Cv0GUtvnKKWuxoxUhpk1Gvtx2nJ5HfwK_Pg)

First I construct the new file named using **sprintf**. **FindFirstFileA** fills up a data structure we pass to it called **WIN32_FIND_DATA** which contains a filed called cFileName which contains the name of the file but not its full path. So I invoke **sprintf** to construct the full path to that file with its name. At line 170 I compare the viruses full name against the new found file, if they match the virus will execute the NEXT label which simply runs **FindNextFileA**, this function will look for the next file in the directory. 

If the file names do not match, I invoke **CreateFileA** to open a handle to the found host file.

I execute lines 188-194

![624x150](https://lh3.googleusercontent.com/6kHt1IR9ia8MYGftEZKC8inlWXgjVwMLeiRyctre-O8ask43B1kVP93D5UUsZh7jru21TTJrY0U1_B1STdmxpZAjtWfr_ewTiSWYM31QP6HFvQ8DwHPCb51MbpwCIJCAfA04gPHjXZByDO7XUg)

I use **WriteFile** to overwrite the host file with the virus buffer stored in the memory location returned by **VirtualAlloc**. Notice how I use **EDI** to pass the virus file size. I then close the file and jump to NEXT which will look for the next file. If another file is not found the virus will simply terminate.

![441x230](https://lh4.googleusercontent.com/3KjJPm65M7gxQWBauNirCduC_jae5-Tgwax9_gU-op3Tcwj5lorNoaEqAZNibxUzu-6Oyh92ILiQeMJDiFqZXoJIUeIHDT4gu6R3ki-BdfsHiqyfJ-vFqYnZ4juWkyQLmXcxP8PiUH3g5cxL0g)

The file **HOST1.exe** and **HOST2.exe** are overwritten. If we load them into the debugger now they would execute the virus.

We reacted the **Mini-44** virus inside a modern windows environment! How cool is that!  
A cool thing about this virus that you can re-create it in C with relative ease, so as homework(which you don't have to do) I recommend the reader re-creates this virus using C.

## <span style="text-decoration:underline;">Conclusions</span>

In this post, we learned the basics of Windows internals and DOS internals which laid up the basics for malware development under Windows environment. On the next post we‚Äôll learn:

1. How Parastic viruses worked and how they latch on to DOS EXE files
2. We‚Äôll execute the Hillary virus on Windows 95
3. We‚Äôll how to bypass ASLR and use the .reloc section in the PE file to our advantage. 
4. How to overwrite a specific section of a PE file instead of destroying it completely 
5. Use creative ways to minimize our infecting code size

See you guys next time!

**<span style="text-decoration:underline;">Sources</span>**

https://www.amazon.com/Giant-Black-Book-Computer-Viruses/dp/144140712X

http://static1.esetstatic.com/us/resources/white-papers/TDL3-Analysis.pdf

https://web.archive.org/web/20111012123012/http:/technoglobes.com/2011/07/indestructible-tdl4-botnet/

https://en.wikipedia.org/wiki/Alureon

http://virus.wikidot.com/cih

https://en.wikipedia.org/wiki/Trojan_horse_(computing)

https://en.wikipedia.org/wiki/Computer_worm

https://archive.org/details/TheGiantBlackBookOfComputerViruses2ndEd./mode/2up

http://www.openrce.org/reference_library/files/reference/PE%20Format.pdf
