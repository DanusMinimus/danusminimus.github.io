---
layout: post
title: Analyzing Modern Malware Techniques Part 4
categories: [Malware Analysis]
tags: [packers, smokeloader, anti-analysis, shellcode, unpacking, reverse-engineering]
---
## I’m afraid of no packer
If you’re going to analyze malware you are going to run into packers, code injections, obfuscated code and what not. If one doesn’t possess the correct knowledge or the correct tools to deal with such problems he will not get far with his analysis. In fact, when I first started practicing malware analysis somewhere back in 2015 I stopped because I couldn't understand how to unpack packed code and I quit trying, So I tried again around 2017.. and I quit again. This in time(in 2019) I didn’t quit but only because I had the proper tools to deal with the problem. Packed code is usually a dynamic problem and by that I mean that most of the time when you’ll encounter a packed malware it’s not going to be the same packed code but if you’ll have the tools to deal with the problem I guess you could defeat any packer. Still I’m to remain humble and admit that I still don’t have enough experience to deal with all types of packed code but I’m hoping that today, my dear reader, together we can bring more experience into our reverse engineering arsenal to learn together how to defeat packed code. I would like to put my efforts in this post to find anti analysis techniques that bypass my Scylla-Hide plugin and to learn how to de obfuscate binaries to ease analysis. Let’s begin!

![168x144](https://lh4.googleusercontent.com/2A9I_-v-62HHDSYfOg4klg6bqnqwOH4JTP250clPFofWaoVhhJ2Ov_AtbnNfLERrfsFWK21r55-3fkTpHBxtqwR5Yd3i5aJk8GiefbrwLVnqGY195pBYgET_ZeXuy_MyW8-Vh6u7)

---

**Required knowledge:**

* Basic understanding in code injections
* Basic understanding in dealing with anti analysis
* A solid grasp of C and WINAPI
* A solid grasp of x86 Assembly
* Experience with IDAPRO
* Experience with x64dbg

**Required Tools:**

* IDA Pro
* x64dbg
* Resource Hacker
* PEBear
* Process Explorer
* Process Monitor
* VMWare

**Sample used:**

[3d2777b748e805c0463c0c6d0fef8280ad197bea1dd0a25e30ed71199989a6b9](https://www.hybrid-analysis.com/sample/3d2777b748e805c0463c0c6d0fef8280ad197bea1dd0a25e30ed71199989a6b9?environmentId=100)

**Goal setting:**

1. Find and bypass anti analysis techniques.
2. Unpack main payload so we could analyze and run it.
3. Extract basic host based IOC and network based IOC.

> **Some side notes**:
> I highly encourage you to download the sample and follow my execution paths. As I begin to dive into shellcode analysis here it will be highly difficult to follow me in the post itself as I would begin to traverse offsets and I would not be making a picture of every location I access.

---

## Basic Analysis:

I was encouraged by a few users in 0x00sec.org to check out this sample, It was stated that this sample was packed by [SmokeLoader](https://malpedia.caad.fkie.fraunhofer.de/details/win.smokeloader) and it performs some pretty cool anti-analysis tricks, so off I went.

## Basic Static Analysis:

**Anti Analysis APIs:**

![602x196](https://lh4.googleusercontent.com/6RJStYjN6PpsQSc9ixD_Otak81_i2vTeTBw3nkFcu4gZ3_eHX0Eg0FYMWeghRbMMwO3DTtz_G1IMdyP3owPPNrSB1VVI5soaJ7ozL8JqsOp-wiRx2OMfRg_3abIucVcpUkPu-db_)

![602x123](https://lh3.googleusercontent.com/GBJUDeEsANX8TelJfqwZH8D-roudUJ2v4Gs4bNl_qjS5AzPLGDgUL2kpn2vUbO190kofT3geNYQoJeU3vrc5zaox3m4wLIYM3oKuJuUtqr7_CJPBak5GKux1nIoLOIZ6j73JWqzZ)

![602x63](https://lh4.googleusercontent.com/_Zg8j9IRQlzBgvKYXl4g-VWuqUjR7_-0S2hMcDt7pKhWNak-C0RSRfQx7I9M5qipi2cZ8B8tBeyQucaxUNbhWvaZbGJD62YJTRRysFPkSg3yHYr80J13kTTOqswkAYdw_D_ZzelO)

**Dynamic API Resolving:**

![602x193](https://lh6.googleusercontent.com/rveKySS3E6JpBjVCuoIX_tsSJ3eEa6G87wSkXPLJ0gsRpwIc8y-vzT4ZwPK9vF3AeDAQeSCjxBOT9B3mWtYBTjA96tR9ifcyk9k7P_WuCCABcRGZ7EFjCLK4-e0RdBzgAR4ohXtE)

**Uncommon section in PE file:**

![602x64](https://lh6.googleusercontent.com/5Q__s-Jzw6hsF7ubWkt_1Xqaur3WIynVDliw3NZ0FJbishaTypwfA3CnEOqO7Q73sBTR2qZu9q_-UJN6lh0FZXqHf7Nvs9MzvGeFQ1YtkVm1YXJgTzxBCyK9LqDDFZyacf2WwdGP)

And that’s it. That is very undetailed for hybrid-analysis. No connections being made, No files dropped, no code injection detection's no nothing.

Let’s look at the sample on disk.

So I start off by viewing the Imports and the list seems pretty full and we have some strings which are well..:

![602x271](https://lh5.googleusercontent.com/NykLSeJpJdD6daw6IBY0TpsAo3hmGW-GABKl27OPmMYENZajn5xMSQaQvhTWj-TgBqICylJYnPf3kY1ncHrmkEmVJbjIfiedUUe6uaaJgEOp4XZlUbCd1bOkUdvX6N9E3ur19hH9)

Not very informative, the rest of the strings look like auto-generated by the compiler so it’s not much use to us.

![602x496](https://lh4.googleusercontent.com/62ksfsKf_3NjLbg2QsbR7oS0DI8f1q4QRhE9o0J7VdE-7tHWL9vifHnPtTNvrp457ocYwAWYv0ntCH8tDXtKDXTU3eJekSs7p8AFj1CKhNDESIoth93bBuRmdyQDOgrMQbZZsE2M)

TLS calls are never a good thing, TLS is [Thread Local Storage](https://en.wikipedia.org/wiki/Thread-local_storage), it’s code that is usually stored in a different section and runs before the entry point or it might be allocated and created using TLS API calls, but there is no TLS section in this binary. Just a strangely named section called **.mysec** which doesn’t contain any code:

![602x97](https://lh5.googleusercontent.com/W8w21sXS0TtGMzf2lJe6H8yuyZdzAJbWlUfCPwEJ1nrTRSqK5I6zzWrntdGq6wVNpuR9X8_9e5p5YSBKKSdeY1jkhaxjr7f96_T6KgLgQZ3rX1NtBHhKIJopV3eXBXFnppartUnq)

but it contains a lot of storage, infact I viewed its full size and its 4095 bytes long. we’ll keep that in mind.

In addition, there is a strange artifact in the samples resource section:

![602x255](https://lh6.googleusercontent.com/5Rvy511QaRkebXE8VgVYFIvFLM2qyEwHcFhWfT5BFXyoPb6ihbtCJcxkx9k1Brkqu3LqkbKB3yOggqb7XEcIZUfPjR1OdCJYtya8V3HzU_A2KOasYeh0TQPQ_rQRgRovNXgo2BKI)

It looks to long(35769 bytes long) to be a valid resource unless its a video format, we’ll keep this in mind as well.

**Basic Dynamic Analysis:**

So let’s run this on our Dynamic Analysis machine, I’ll set process monitor to watch the application and we’ll take a look at it in process explorer.

![602x237](https://lh6.googleusercontent.com/BB54HW9eHzPsLz8b1mQbkYOs6fX70eCHp-Zb8g_1qpeu7XC5L7pldVkZDsH2GAkmaXHlZsUFrVvoCB3bbe-dmOpyXIK94byU2BZAPV5eNMijNzOCuI8p6eWWvNOr0fSc1Gths0Sg)

![602x277](https://lh6.googleusercontent.com/nsaYmUp-CMHcH8vxvRDrNBu0IX7dvF7eDT-y28-bFM9LTqxipp-m6PRdk7JFg0h92FIGjQju6x22FBm-NG4m1X4KpB07TzucKVG0sAiJjk3kL9y5sy4HRz_OdoNHNsejIfET-Z8_)

![602x331](https://lh5.googleusercontent.com/ZYZol687XLVeqx9W8Oq4TRhhx0BAprtMJF_E9yvgkipTo_77fZaxblcFoUA2rnrzr-ldkvMEPuCCpEtMllsLMvoW7OlhXJCyGlfkciInmHCQTjc1eZTtoxMwqFSDRqYwzb9RUUXg)

That’s not true actually, I’m not surprised at all. but we do have something interesting here - it appears that the sample spawned a new sub process:

![602x27](https://lh5.googleusercontent.com/6bUx-mBj1zCDkvgc6L823FM1xXLXvqLtRpWX064g8rps03xsaF8dqT6vt2omzzUW3sSw24pN2ZRxAiQrGvrQH9VHzRWY757ASvMfFYzLVJTEVB2Q6amzBbVdXClZARAcyOs_DX7Y)

which is a legitimate Windows Application, that might come in handy! so let’s move on to the advanced analysis!

---

## Advanced Analysis - Finding Obfuscation and Anti Analysis Tricks:

Our goal here is to find obfuscation techniques and anti analysis techniques, I’m going to find ways to circumvent them, instead of skipping these like I usually do we’ll park at each technique we find and see how we can deal with it.

Before we continue, I want to mention that [SmokeLoader ](https://malpedia.caad.fkie.fraunhofer.de/details/win.smokeloader)is simply a loader aiding the main payload in covert launching. According to Hybrid Analysis that was linked before and [Maltiverse](https://maltiverse.com/sample/3d2777b748e805c0463c0c6d0fef8280ad197bea1dd0a25e30ed71199989a6b9), the final payload is ransomware(GandCrab according to Maltiverse).

Let’s start by looking at **WinMain** in IDA:

looking at **loc_4011C5** we can see a lot of local variables being initialized:

![261x554](https://lh4.googleusercontent.com/xlFWtDnMqsS6nMbDtL3GsWFlk0auvjbVOI9cslhABVfB4-fmGyKzRsVsJQlVVisWb9LrQlgcV5zx3BkPGos0Rc0WWttcP96ml0_30g3tjOy7oYx5Tvao3T2tIOxzOnhR2AlIIzjD)

and since I’ve already analyzed this malware a bit - I’m going to assume these are [encrypted stack strings](https://www.fireeye.com/blog/threat-research/2016/06/automatically-extracting-obfuscated-strings.html) but we’ll see if this is true later on. Next up we got mambo jumbo code that is built to look confusing but legitimate. But wait! oh boy what’s this at location **loc_4017F9**:

![309x342](https://lh6.googleusercontent.com/nDSMdn71hBUzFWdflqrNkO__tKU1PvPGT7gCQRbw-WU-4yI6Bzulzrr6k8N8m0OVxuOmiheXoO9qa3gyjgN0fFUkzB6k3rzfMk6jemFx6-yYWMopInKxiiKEoG_TChco1x0kmlta)

A call to a dynamically calculated value and what appears to be an attempt to set a value in the Process Environment Block? What is at **0x2c** being accessed from the **FS** register?

![602x24](https://lh3.googleusercontent.com/QoCHKKL1HKw5b1CuGpf5pRCz0lQMayCYiHigTv2VtpG0cw-enhcLLDoJeAFBRidZvsR_PwpV-2IKJB2SMc4S2D1x9ii9ollnQbfdJUG51ZqxwBx_pKSKlu5-gIZZTOEE1a8UWMuN)

Huh.. It’s attempting to access a value in the Thread Local Storage array(TLS), we’ll check that out too since we don't know exactly what value it’s attempting to access since **EDX** is dynamically calculated.

After this the code block calls **printf** and terminates, I’m not sure this invocation actually does something.

![346x286](https://lh4.googleusercontent.com/MqtI4mvdYiKq7U8FE-1vH_mYLXE_16aeTtuCgXf-E7LQbUMJBQVSq_NdB46GuwIiPNkcQ_Y5vDEtoF4zq_Gp0YL6nD4Rko86eiZoyJYny-vdodJOABeN0wb8v7bu0JtCUyM1G7oL)

**So let’s summarize what we gathered so far:**

1. A shady looking resource
2. A lot of local variables being set up that look like encrypted stack strings
3. A call to a dynamically calculated pointer
4. Dynamic access to the TLS array

Let’s start x64dbg and put a breakpoint on the assumed stack strings, and **loc_4017F9**. In addition just for safety let’s place a breakpoint on **VirtualAlloc** and **CreateProcessW**.

We break on the assumed stack strings at location **0x4011DE**, now I’m going to access the dump pointed by these variables after I run the entire variable assignment block at **loc_4011C5**:

![592x59](https://lh6.googleusercontent.com/6anYlvJKUfoxyRYjwDQE78Wlm3gdXn1VM1PsVIOkdkY-mxwTQNErG5sX448J4M7-AhPv-Zhg7li7XYq5a48_Xx__8LnbbAR2kiScuWQmV8asDeAM_2KOzEiZ7nICk18MjVmHk8Op)

![357x22](https://lh6.googleusercontent.com/5BB8iv-IqfzI6F-EXd-qb16JJVZfnwneCE8VwJUzGb0FVYGgyN3QBLXb0ubnSUgW7BMR2y-wh0KGHdOubAb5ek_GQxqxF7kia39-xOaEwhytY6tLw7g7tw_ph5ywMtZFjswJvC1_)

![405x23](https://lh3.googleusercontent.com/ofAfwFNUVlANKwYYYNoTlQKu4H0Rfrn8VwxCEc8meiIq7dcyu4mNvbEQz8hYiMxJBal8aUTrFS67-nhueBZlCR-mv3bSTkKzTo0mbgn-MwIKNO0URKkWRrFPHMBrszcObmqKHF1-)

This is data, but I’m not sure all of it is data, we’ll see how this plays out later.

Next we hit on **CreateProcessW** which attempts to create **splwow64.exe** which is the printer driver we saw the malware launching before with command like parameters:

C:\Windows\splwow64.exe 8192

But it seems to be created because of a call to the API **DeviceCapabilitiesA** which is not much of interest to us.

![602x149](https://lh3.googleusercontent.com/bsLyZDW1URUxgr82_DTxYcCg3LqvwH-h-dRCvhehP42SUbZbwQv2mQE-_GT7xAdRAUkGSDB9l5gkqBoY05DUiOkza1E3Jjo6zmJHMw41rexShIVAZx-KV3tEeUONvA4_p9VyJ5iA)

---

## Trick number 0 - Embedding shellcode in the resource section

Next we hit **VirtualAlloc** and upon exit it seems to be moving the allocated returned memory to 0x4260AC! that’s the address of the value that is going to be called later:

![253x25](https://lh6.googleusercontent.com/PiVdEF6cXW4SSiY2ecUD7ptWxzvSEcuLqkTzA9FtruzuGXTb-eKtD0Oj_IAT3UH0ZLpcVZe35aEYzbg56cXl-1t_J3-GyIu7DI2m89FWR0zRQQVeJKbJ8cHrBdah5A5GK6QxcNbD)

Let’s set a hardware on access breakpoint on the returned from **VirtualAlloc** value:
![602x323](https://lh4.googleusercontent.com/1XFJ7NhtoDT6nmzLYCyWee4a0dZ8XvUrtG_ssmWlbNnC9cCNO-IztRmTqSOh_07scuzdchfaeP8lAqdQBF1UgSD746vPWNPWI7ytEBdxCX9W1ryiZSlhp08nvlwd-m_Ii6ZHy56r)

It gets accessed a few times and after 2 times of hitting run I land at **loc_4017F9**:
![602x215](https://lh6.googleusercontent.com/xSDf6X9Kivpxrn7JfnI8P_7PmhE8tFdHMWA6W97KyQeSihoedlniuHHV100604HpFyvHPmwtd5X5pJ-wLhKtG35aN_pV1rEhfRNmg5nxVa9T_EH_DxFB9TGYW5tuNXFfxwjqADIS)

I decided to look on the dump of the allocated area returned from **VirtualAlloc** and it reminded me of something I've seen before:
![594x16](https://lh5.googleusercontent.com/iUFkxAlKYIDHlTzl7Dc2vvX4HPkqq2WIp5uRJj7gGfKhTMu8FBNQn1OHPOGg_t16zjuQfkFON9bjdkYx-a_wW_1ZvBJY9vAKPz3nmosgse-k-CS0qvSi_H2bfjP8jFuDgtf1YiWB)

Wait, let’s check the resource section of this sample that we looked at before:
![522x18](https://lh4.googleusercontent.com/7MXZjsUx7zf7kg1K1TUjqrDYELOR4dI-Jb5M6DFnD8IKlt55sB7fEP2qhu3Y_C-9epHbDN7AWUJiUFTQ0053oaWzsgwdzEcTnLr05O3F2cHDgn0ePJ1emx_rU9E1HL85VuANxAOA)
They match! hmm:

![244x93](https://lh4.googleusercontent.com/RFGeK-vTYlSuE8NaOUllmQld-u0RKNB1aKhz1JvkwkETiliJ2Ulog_ERuqqyoVipqF08u5JEKXIJ5YTraySvVXzBTvODZgYI7p-ZzbrRjCe-pOR3vjc510i9suPbmMoBlrkcnulG)

Before the call to that dynamic variable at **dword_4260B4** we see that another DWORD is being used located at **dword_4260B4**(passed to **EAX**). if we look at **dword_4260AC** in disassembler view it doesn’t look like valid code:
![602x264](https://lh5.googleusercontent.com/IM-RiKyDOdjX7pcWaQvX9LWrfpwwDOLKpmey2Au3elOxBWBDiC8K8cxDd_l5kCrvguFV_R5WG8NaPGbwUukXKjLWbBa5DQMkrX-E64QwKDxc4ILiPzTP_LZhvdOtPc2yZzHkjEQE) 

So this little invocation at **0x40180E** to **sub_401110** gives me a hutch that it might lead to a decryption of that entire resource.

**dword_4260B4** holds value of **0x8BB9** and if we view the resource length that was mapped into **dword_4260AC** we can clearly see they have the same size!

![242x25](https://lh4.googleusercontent.com/VVM4vrREbL2Gc5EqdzWM_iSUbxSGlwBhln3TuJsEavdLiJpWwHLwryqzBZh_kye5UmIvT1UbGJ61W72v67DHcRSw0OFzHE1QAzgU0mHGVxE2PSYak15aCObkpvoQD6ytzrQSUJOJ)

I decided to rename the variables and jump pass the call **sub_401110**(func_ResourceDecryptionRoutine) :

![354x265](https://lh3.googleusercontent.com/mH_71PTC3q2igJitvee0IcnHrhfWpcDbZxCg5d5_QYfUhk9X-5G8z2E73hV5rmMujPeUTB0H5fT_faC19DNSlsIs7mh9lNVBTR7oowIbZkE1QEFNYXNt6uo4oh0SwhtpM0S6U4NF)

To see what will happen to the resource section that was mapped into memory I decided to place hardware breakpoints on **dword_4260AC** to check for memory access, after my hardware breakpoints got triggered the allocated resource view in disassembly turned into this:

![602x196](https://lh6.googleusercontent.com/1NXiOD2U4qIqnDIQ1wNYL4u6wRRknY45lpEAL90XSGNGDxTH2GjJqcVqEQ3oQUGkVJJxWMl2VqQaY6fQHvgDBGIDEMUhrQ8TPMhKtJT4PL_CH2UOFpj5nf71gavm1lC-jmw_9cOj)

Awesome!

So let’s enter the rabbit hole and see where it leads us, but before we do that - let’s dump this into memory to see what’s going exactly:

![602x241](https://lh5.googleusercontent.com/GiCQ-f9mP3TBd8vzmaQ9l0CHlJQR1wBJ1wbKTDVV8aPq8iFEv9i5ODgTPslA-A9Br_CZht7SVHmDUHQbaB4AgAnt-myo5o0YNisM0x99WOpyDHJidzfv4laJLifjkSm4Fyv20OZb)

IDA view of dumped shellcode:

![602x316](https://lh3.googleusercontent.com/CtBznUbsNSMjRGTNb8uWwUjBPtat6K3CucEzHhzjPmCqy-iIEiCYL1-CWa13DgbmLyZYuLGRFiReQPeg7dF6Xur-Nq1xLAhPugRXy9mREiYSWxTaj2CeN6RBVSaiwAR5Gk49Z9ey)

I’ve analyzed the dump a bit, and found that the function called at offset **0x33** is where the main execution happens but unfortunately it looks like this:

![125x422](https://lh6.googleusercontent.com/sif1YsUblJrmxzbTC2HVIv4_0RCF38rDsyyEXcAXaGdBXgXopeUKjK1nXBEkOVugnhREmRaH6AFEa3oSNFxj4IsxgkBbaVUmsd1Q2bngIwT_N0IhUMB_p5Czgv0UcNPh33Ft6ppc)

Let’s scroll around the IDB to see if we can find some interesting anomalies:

Our first encounter is at code block **loc_4C:**

![285x425](https://lh4.googleusercontent.com/uOLOzAuEZ7nNtcKV8nHSYNR5f13lIQi7Q0X4i7krK4hdj89T7UcEbLQCwght1FcdXQ0WAXhUcbS2gGQ29wc11nf0Y3pwAG1-6XcotaXARXvf1ZRYr_Tr3kkhWQg3EpaA_stbK_RL)

---

## Trick number 1 - Stack Strings

This again looks like stack strings, and they all contain a call right after the push. If we’ll attempt to parse these strings manually and turn them into ASCII strings we can find something really interesting:

![210x340](https://lh6.googleusercontent.com/Gv5-kAJO35IgjOHsxcQgjRHB_qTfcT_dz-LfNKl2fl0xGfK8Um8VwwZxi7qQ10fv0eNlGARYDKem0poGHlhU--17BlkBkUwzNQrnepvLTktr9nhVSnk_SJARPge9FxR4GuNxtpRP)

First it appears to load **kernel32.dll** and **call [ebp-28h]**, Then we see a push to **VirtualAlloc** and a call to **[ebp-60h]**. Each time a new function string is pushed, **[ebp-60h]** is called. I have reason to suspect that **[ebp-28h]** is  the address of **LoadLibraryA** and **[ebp-60h]** is the address of **GetProcAddress**, we’ll map this assumption into IDA:

![169x514](https://lh3.googleusercontent.com/-3IC9-r3W6iuZsd-rYK_sxJAZjqhFJ71DFHT_rAhLFfjQAT97BDeZv2fQLnv99grkTr1emHeiflYgdwnAkhN4tWSw2WusjZBmvGea_aw4dGGQvEeJ6tAK0gU99g0IOQ762iEwW4-)

This mapping actually aids us to recover more artifacts from just looking at the the dumped memory statically:

![174x323](https://lh5.googleusercontent.com/hfXYjLXm5Y5TSD0EtDQqvH8c5AT0FPSj0d8cxfavijZJhLPpn8K90UnQC4s5eYWcO8rzscb7zeNdpJJi0Qsg94cWiKzpn1TYGC5KCmkPaLukKdON5u3TyPUHzCrIfmQe6V_8wbr8)

Let’s debug this memory dump and see if we’re correct:

![602x31](https://lh6.googleusercontent.com/RKX-or1FSVDBOy15whFJGuy6Zgq8wrKsJkT7GnVwLv0HR9HUSmo54kXOFY9Ot1R0qxF9rMSRVSa6rhavrmwLzx15hFFbnlMbGu5BDgPX2O7M7nvYUF0nvsyrcXoJLQNMj1Kxa-qv)

![560x25](https://lh5.googleusercontent.com/hhO35C5yAVu-jZ4gwwSwH0zkW7enTtS1qdPpNRl0JEeX_xPw6a90OuWHNxJNkvdI038VCFyjuw0q2YDdVGfSkPIHbr6lVQdB9qqA1HhrwsKsYzgihjBXviplS0vuG_tHQA9YGWkQ)
![602x31](https://lh4.googleusercontent.com/x2f5-_PLdJ3-m7e-8D6iBPTXgEe_qtbaq-jdoXmzoQE1Vuahdvz6Bqeg_PVrjVCmgNO0T3euwbPNQzFyGLF5sFamYx6DYs08Hdr3D64IbOrKExDvxN0CRCf1uNHkdVHDMC09j2fV)
![598x13](https://lh5.googleusercontent.com/kXDZ7YsOHTcJQXh_496B_vXZWZYwobriSD5B4ZcMgKg5JR2eJ_rcECs66xWGS6w4I91SmQfHXKl6e_QVP7YswhBaTZ7JncmXYJ9y_2ZkOT8N5tDwUiBiQKTIwmlh2SVawhhWU1_G)
Our assumptions are indeed correct!

---

## Trick Number 2 - Handling Dynamic API calls in IDA:

![267x158](https://lh3.googleusercontent.com/iAmVU99I9vshfBo8w5N3lfPntCjWB9McgnoGeew0QePv0yPC-rVvxvF-siVYoRL7XPeNy27L9y7NZzL2_AkswS1zn-3EYWzQbhBJXKPrSO3Cd-fUgwbomuq8gSOLcIkdHv0ThJ_G)

So we have this issue, The base address of **TerminateProcess** is going to placed in **[ebp-0ACH]** as we can see on the last line(I’m assuming you guys know that in the **stdcall** convention, the return value is returned in **EAX** and that you know what **GetProcAddress** does). We can't go and manually map each and one of these by clicking K on each local variable like some potato, we must edit the function so that IDA will know that any time the **EBP** register is being access using offsets its actually accessing local variables so let’s tell IDA it’s an **EBP** based function:

![217x303](https://lh5.googleusercontent.com/BlMSLJqydiHU-FimMQtEBXrG8IyPiqn_3xCHDswYKzd5qNRb-yzsdVBTjHXJ7h3Gv8hc0TbyIqKA9JQ7Wff9odnfjRa7VB3Az0Ud5gQBNPs4KdLel7bPewMtOhTNdGf8eVSmnz30)

Let’s click edit function and mark the function as **EBP** based:

![338x242](https://lh6.googleusercontent.com/YJBNmFaViE9u8rpBFTJ3U-LMAsYsSvzxnFZlsG_hpIW7Iw70KLzKFTxMVmqCbzF2DWOCg5zztcUh0H4-lz26mwzuF_mZZSXBZV3Xnfo300YNYvYybsa3hwKeOXl_JDg8eWw7XrfU)

Now we can rename all the local variables and see the changes get applied all across the IDB! So let’s fix the dynamic API resolving local variables and keep searching for anomalies. I didn’t find anything worthwhile so I decided to place a breakpoint on **VirtualAlloc** and see what happens and indeed we broke on offset **0x1B8**:

![379x221](https://lh3.googleusercontent.com/G62s8ZolzV9sikm25iKazqZkey30XoxVck_gMq35CwT5gJnscX9ssjMlTV_Ga0WDVByL3a9RK-5Fd3XxevRZOCx9OJL_H68OM8KusPgqhjuVu_C2aVnfbjy4tzdNCjuXSoHLnMsO)

I’ve access the dump of the newly allocated memory which is passed into **var_10**.

Let’s set up a hardware breakpoint on the first DWORD of the allocated memory and see if it gets accessed:

![589x14](https://lh4.googleusercontent.com/stbB6-eWABuvRZTRD2xVoJgA2Qtfh6_6QOFT1uTJfs0_FG_Rsc7mjjjZ025_91OqBYH1v-LJcTaamhmViV-56a6aNmz6GL0SNwZPUh3P-AMIJnvXF0y_rYCz_FdkAyIpWRUzYgBw)

---

## Trick number 3 - Dumping PE files from memory:

It does, and with a promising **MZ** signature that might indicate that a new file is being mapped, now we have to be careful here because I only set a breakpoint on the first **DWORD** of **0x1EB0000** - if we execute another time we will lose control over the malware, When I did that by accident the malware began to start an infinite amount of threads to circumvent our analysis and crash the vm!

We are currently executing at offset **0x9B2** inside **sub_978** and if we look in IDA at how complicated this function is we’ll have to collect our jaw from the floor:

![349x448](https://lh4.googleusercontent.com/yBmr0mv7mn8fjCX3_9dkxnsNAYLDFYZJ4z2LlAqfBmNAv7CHdKWc4K_bJzsUzEiLdrOV_ySOBTOLtCM3ZqmBKCQtuKi9zLWqOvPH_a61XhHtb7Ytv36XZdLIUvRT96NmJH1uB9iJ)

Let’s assume the **MZ** signature is no coincidence and a PE file is being mapped into memory, maybe if we find where this loop end and break there, we might successfully map the file entirely and then we can dump it!

**sub_978** ends at **loc_BBA**:

![181x354](https://lh3.googleusercontent.com/Wbeth_czOOdQgMVl4D_NGCxn6HhFOa57IlGxXqzk35YBNQ6OS_RUeRfJK_0_MoOYnN--0u5_fIx1XXOb5ocMwxW-_PCkzF3zWbMF28xF-VB3Bm2gP-ajwrH2nPMxssTxMoSBudXz)

so let's set up a breakpoint there and see what happens:
![592x169](https://lh6.googleusercontent.com/KksWcgFuOgny72-7FR_p_CFautRnQR3fUay4FBQ9WMfN7MyWm_p-O3GJ8krGuYsPI6X5Xy3vceZ-RXKzu7Wmo_xsgsAuum0rJfIsNEsjcZIWLhDVOvTBcqafTKZqzLKCrfhF3dw_)

We were correct!

Before we continue execution let’s dump this PE using Scylla and see how IDA will parse it:
![602x317](https://lh5.googleusercontent.com/-lrK_UFEahH3HbGstwQC5rumE4_Q5nlc1CVE9PMoQc4I1tYo680o0p4c6wBtjzNnWYcec-Bc0lnV55iopRDbUiAfRGeh-pIXbWP7T-WDO_4IBAlbgqnAteT73_mqi9Tpvg-wSJTE)
I have seen this before, but only in books. This anti disassembly at its finest. It attempts to trick IDA’s disassembler by creating these faulty jump instructions that will just into the middle of other parsed instructions - IDA doesn’t know how to deal with this so it will begin parsing instructions incorrectly. We will deal with this later as we are not done with the first binary.

---

## Trick number 4 - Self Loading, [[heavy waves of nostalgia intensifies]](https://danusminimus.github.io/Analyzing-Modern-Malware-Techniques-Part-1/)

Let’s go back to x64dbg, after we leave the mapping function we are supposed to land at offset **0x1E0**. Our next anomaly will be met at location **0x1F8** where a **VirtualProtect** call is being made:

![602x12](https://lh5.googleusercontent.com/rmKhix3xFrp4zvehtIH6rwWsSWaBxRiESiNz062cPVF1jRpMST9zIGZa3pPQmxfwEjWhZBfOvnxvbj12vLG9rdbgMUOXFEttpNaVlBgcATvO-HxvsciTS_L6dBvo4cwI13MFXbyp)

![294x55](https://lh5.googleusercontent.com/FWoZXhOYod4L4INNrgan4PUFF04UlPUxewRkKuzf9d0kaKQkR2PDXyJezqrT_gGFwrWxDtQVMvSapXppWjS8MA2IhxQbUrKwW2iEiv9ZekmQ7Nq-DSnigwlEMcYSAV60gKkzP2ED)

On the base address of the main image? what?

![602x11](https://lh4.googleusercontent.com/C8Kf0yOaA0xkQXyhmUA3BKhsNTRRB3e_NxuugG12P7IV8J2T-RdfhxrZ63KoCKRHHyCHZ5qS0cyfCe7X8I9ul3grBdeH1IaTM02_52AV98JxFRRZk-USURrIOEvIKSqY4fNHH-ZN)

If we execute the call, the **.text** section which is responsible for storing the code of the PE file has its memory protection changed. It can now be Read from, Executed and WRITTEN TO, that is not supposed to happen! let’s see what happens next:

![269x483](https://lh6.googleusercontent.com/IwnKc3sgaFiB2hzMCZDJ5olKnaXrOJLAlrdPruvpgOZEbo-KbQqeLa_QUxvXg2D-WhJbL71mX-NFfrWTZDPvTrYm59zkGknJ4uSM3uZ6ulV2UeBMdeCkEHXs1bTdEHTiKAZj-6pA)

We enter a **sub_BDD** and if we view the functions behavior in the debugger, we can see that [rep stosb](http://faydoc.tripod.com/cpu/stosb.htm) instruction will begin to copy the zeroes stored in **AL** to replace the value of addresses pointed by **EDI**. **EDI** is pointing to the code section of the main sample! It’s rewriting its own code section wow!

![602x369](https://lh5.googleusercontent.com/rCqUcNX5EOpK6q_EJhYhSm16Pbc1sHYofG6rfG4eCNkAMwlC0RnnwF4y62B7CmH9EMNtaUpAL46-mozUW2pqv9nDZ0ophsfciHsUwaYTzCWwwNTwNk-PblxYXsn8wAReGxXOtOxk)It’s gone!

I’m going to assume that the malware will copy the newly mapped PE into the code section of the current executing binary. let’s see if our assumption is correct.

When we exit the function **sub_BDD** we land at offset **0x220**:

![602x163](https://lh6.googleusercontent.com/iN1rEM1k5IgjgBvH4chmMjFs0qVqS8SUhs566APWI_pHATKFw60vGePnNwHQ6Cvm9o2nhyakwY0aM9Su0iUWe8ZCJwP7Lsm33tmBpycV4Gha0wByfNCmx1kpLMSO71j3hrYWO_3x)

If we keep stepping over instructions we begin to see the string **“.text”**, which gives me a hutch that we’re are traversing through the PE Header format of the current executing binary and come to think of it, if we look at offset **0x22c** we see:

![214x23](https://lh4.googleusercontent.com/UsjdK15BKAX2rnv6ytQs38iwKYwKAA8dYJXMx0s7OuBnGzQf6UXgdvc3YYO2yCWgYiIkAtpSW0Glj0ntUvfiE-v0yEj5SDeXtKWj0UxcZaq8B6_sC7xxGrE0qhEh5zC62zPEpE2Y)

And I know that **3Ch** is the **e_lfanew** field in the PE File header format, hmm.. Lets trying to map this in IDA and see if this assumption makes any sense:

![422x373](https://lh5.googleusercontent.com/BlT58TU3x3zMN1fsNGoi7Zf2kA0X6ih8ghnpHh9FcriHphJdO81Odpj-4dIaBJbHZwufvWo9YDwZXYosDj0yFhyZhQwOlV9RPe84rloNjWfu5ElftSBeOvtXeWHCdWs8nHfh6FfB)

It’s actually traversing through the newly mapped PE file!

I mapped it and now will explain how this entire process is done:

    mov eax, [ebp+lpvoidVirtualMemory]
    mov [ebp+lpVoidNewMappedPE], eax
    mov eax, [ebp+lpVoidNewMappedPE]
    mov eax, [eax+_IMAGE_DOS_HEADER.e_lfanew] ; Get the value of e_lfanew
    mov ecx, [ebp+lpvoidVirtualMemory] ; Get Image base of the new mapped PE
    lea eax, [ecx+eax+4] ; Access IMAGE_NT_HEADERS by adding e_lfawnew to the image base of the newly mapped PE
    mov [ebp+_IMAGE_NT_HEADERS], eax ; Save the address of _IMAGE_NT_HEADERS of the new mapped PE

---

    mov eax, [ebp+_IMAGE_NT_HEADERS]
    movzx eax, [eax+IMAGE_FILE_HEADER.SizeOfOptionalHeader] ; Get the size of _IMAGE_OPTIONAL_HEADERS from the new mapped PE
    mov ecx, [ebp+lpVoidNewMappedPE]
    mov ecx, [ecx+_IMAGE_DOS_HEADER.e_lfanew]
    lea eax, [ecx+eax+18h] ; Skip to the first section of the new mapped PE
    
---

    push [eax+_IMAGE_SECTION_HEADER.PointerToRawData] ; Push the address of the first section of the new mapped PE
    push [ebp+lpVoidNewMappedPE] ; Push the Image base address of the new mapped PE
    push [ebp+lpvoidBaseAddressOfCurrentPE] ; Push the base address of the current PE
    call sub_BF6

Now let’s make another assumption - after the call to **sub_BF6** at offset **0x21B** the code section of the current PE will be replaced with the code section of the new mapped PE.

And that is incorrect! Fortunately I put a hardware breakpoint on the the code section of the current PE before I continued execution and the copying actually occurred at offset **0x326** instead of **0x21B** BUT with a call to **sub_BF6** so I was kinda right :), so let’s put a breakpoint at the return instruction out of this function and see what happened to the code section:

![587x152](https://lh6.googleusercontent.com/w6EWjw0kdzGgm8trZKVUPX7L38G1pACUNodpE7Wkbwfda8Af94Gd81hY0zog_Bn1MpaMzipxBVg8bvadrRNoQXRzc9od0fsauFJx5sQdoeTrtrwByeNIBXzpMzHC30PcNFHyBIy5)

![594x162](https://lh5.googleusercontent.com/QOMFSEaNM7p3iCCJ0Yh4BW2KcGRPbH4NykOYRoBsMPPoabqqrCTKh_RDR4PZgLep2Ggn3tAwhqjJSaKKU3l7BeGLc4FBQ1mpmwy7jT2YZNK6ZmFR72Q_4cZu-bmt3NQkSA3RmTXQ)

Very cool, but this code looks really strange because if we view it in disassembly it looks nothing like what we dumped to IDA before:

![602x388](https://lh4.googleusercontent.com/QK_kp-XadG7oCk8DnMfS3p0pvTdNqC5_Q9WN8fOysbuJmIyF7oFqW9oYUX4pvNSaZOcwOT-P-ybGZ3pkkfvVl2Uv2nNLmLBH3F0DcaA4Mnvznb6TSV_m6bvWjNy7Jb8isCRQ0e9L)

Let’s keep going to see if it might change. Our next anomaly is at offset **0x358**:

![548x14](https://lh4.googleusercontent.com/p6oYnbvlcoV-tZgnwkQtxQEqmY_8vDcCLiG5GJ6oxucX_8UVFhRMpcBouxbMbh2Wz4iK3orMJ0OiI04awOW8loNaBq3dlBSOsLqAfgbIbvVyH6nbDnB59KDbeaIu2cxmw3ypkdkE)

![213x69](https://lh6.googleusercontent.com/e6bR_WRLubyr1KqM0DiukyFVIYQUP3M_uZMnhtdcpGtwO81Be79BAl0vdtRdWy2xlupYi0JFrO12F5sItBR8ooBRb6J6iFy0iFRIFPYh8HkH7AgJEb0oafM_qAWVK1Jxw4AhKzLn)

The newly mapped PE gets free’d from memory, alright this is promising let’s see what happens afterwards.

The last anomaly that occurs is at the bottom of the function we encountered when we started analyzing this shellcode(**sub_3C**):

![355x293](https://lh4.googleusercontent.com/0QkYs0OtAQb9M1d9og_M-CKexs601LIIFk4gM947npJFRisDhKmuaXXE9_SrTwlHahrZ2HUPDXkhF0OKRILCjNzQIx8Gy5wYDIYyeNLHR5EDTHFFneP1RYn5OmEl3pztg4tyILb9)

A call to [**atexit**](https://docs.microsoft.com/en-us/cpp/c-runtime-library/reference/atexit?view=vs-2019):

> “Processes the specified function at exit.”
> 
> int atexit(
> 
> void (__cdecl *func )( void )
> 
> );

This function will execute a callback function that will trigger when the process will exit.
So what was the last value pushed into the stack?
![150x16](https://lh5.googleusercontent.com/wqFPlICu-zPHi2MvJCA0b56gl5g1zo8r51xdASult3y0NgNzBUqdW9LRYo9RWEqsmPQNbKshCeDUrPUh99CFxbIwQ0OnZWrI8LnlR0nZzqqS0roQNWOED5Dx27CXkoJw8_HX861A)
It’s an address, lets follow it:

![597x52](https://lh4.googleusercontent.com/B5bFSrTGMLhm2e-b8otvkYphpLtDkp85kYi1qf4yCedw2zx_DVpb0aE8c4aPrKTXvjnF2Gu84sQSDviUI1yAFeTpJfJeSp5uUzRktKaXVY10FjPOqq_O4Uol8Zo9YGPM2l3JjEHp)

It’s going to terminate itself upon function exit, alright but is that it? well, not exactly.. at location **loc_811**:

![342x190](https://lh6.googleusercontent.com/ZzVWi2S1dhhlQu18Ns_9PaGbmT2AFB6Xf8us3m8BjppNAnfT-qosSpxQ5T14V6ltIdi0_jdltBSaOHkcf1rdJqk5k2CdxSqbuwHSlS-F2sGZaMGpXODSsAvYr7mKb13009He12jz)

We jump to a different shellcode located inside the code section of our PE:
![298x23](https://lh3.googleusercontent.com/0yoquy2C-kU5MP20mEgRvS6iVf5qzzT9XVbh-BZ3u9xSYLMXJ1rAHUS_znno1CWun5bxcD34ywTCeDqN9lORWrBBMItlI69DTIwZcUcS-OejCf9GsKOvjOm0ic1rU8aVt-vPh03s)

Let’s look at the newly mapped PE that we dumped in IDA at this location:
![602x147](https://lh4.googleusercontent.com/A-4lJrMRsNtx2gOZ7bSWDh19AowBueadRQbJ9uaprDCKvHoEZn1dtj7g_2Sb8xFxNJq2CQMpboIPvZY1nkNk86NAQvAR4fUtN380zodjHpSGD4LRmSTMJz8mYuSKpRxkSnUe0rEn)

We compare it to the address stored in EAX:

![602x113](https://lh5.googleusercontent.com/y2LeAZ96xLotwDA9HQ82MemqxAurLElsRG8ss56G9gVWCRcbI5w-t3amVX5MZyZJU47CPeDoQsqMmrpqe7Jj6C8khixn2yJx4y4yo5jMWa8IAhQdwRJAhGf17fDcYKjyqgcIGPc9)

Ah, this explains the reason we saw garbage code when we looked at it when it was first mapped to the code section, its because the address of entry point of this code section is actually at offset **0x2B87**!

---

Alright, let’s stop for a second and take a breather.

## Summary:

In this small blog we covered 5 neat techniques:

* Resource embedded code
* Stack strings
* Dynamic API Resolving
* Loading PE files dynamically
* Self loading code

Again, sadly - I’ll have to break this post into two parts since it already become to long but I hope this helped and aided your analysis toolkit. On the next part we’ll be analyzing the dumped PE file and circumventing it’s anti reverse engineering tricks.

Till next time!

---

## Sources:

https://www.hybrid-analysis.com/sample/3d2777b748e805c0463c0c6d0fef8280ad197bea1dd0a25e30ed71199989a6b9?environmentId=100

https://maltiverse.com/dashboards/newioc

https://docs.microsoft.com/en-us/

https://www.youtube.com/channel/UC--DwaiMV-jtO-6EvmKOnqg

https://malpedia.caad.fkie.fraunhofer.de/details/win.smokeloader
