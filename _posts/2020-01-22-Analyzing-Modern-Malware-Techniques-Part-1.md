---
layout: post
title: Analyzing Modern Malware Techniques Part 1
categories: [Malware Analysis]
tags: [fileless, kovter, reverse-engineering]
---

## Fileless Malware - A self loading technique
Fileless malware is nothing new, but is very much used today. The idea is to load a payload into memory and to leave as much as little evidence as possible on the hard drive of the computer. This can be achieve by various techniques such as:

1. Using PowerShell to further infection in the machine.
2. Using the Registry to save malicious payloads without dropping them on disk.
3. Using WMI(Windows Management Instrumentation) to collect data about the computer.

These techniques go under a category called “Living Off the Land” which means the malware authors utilize Windows tools to exploit and manipulate them for malicious activities.

Today we’re gonna look at [Kovter](https://www.trendmicro.com/vinfo/us/security/news/cybercrime-and-digital-threats/kovter-an-evolving-malware-gone-fileless), a click-fraud malware, it's file-less payload is a bit different from the techniques mentioned above. I will be looking at its unique way of loading its payload without dropping a single file on disk, I’ll be exploring a sample to show how it actually achieves this.

**Recommended background required:**

1. Knowledge in C and WIN API
2. Knowledge in x86 Assembly and basic usage of IDA PRO
3. Basic understanding of the PE File format

**Tools used for the article:**

1. IDA PRO 7.0
2. x64dbg
3. PEBear
4. Resource Hacker
5. VMWare Workstation 14.0

**Samples used:**

[4160d0e5938b2ff29347476788f3810e ](https://malshare.com/sample.php?action=detail&hash=4160d0e5938b2ff29347476788f3810e)

**Setting up some goals:**

I found this sample in a [malwarebytes blog post](https://blog.malwarebytes.com/threat-analysis/2016/07/untangling-kovter/), Where the author goes into a brief mentioning that the sample loads an encrypted PE file from the resource section. It maps the file inside its own memory and dynamically resolves it completely, without dropping it on disk. It is then mentioned that the mapped payload lives off the loader host, it depends on it and without it, it cannot work.

**So we’re gonna be looking for:**

1. Resource section handling API(ResourceSize, ResourceLock, ResourceLoad).
2. Any memory allocating API(HeapAlloc, VirtualAlloc).
3. Reference to any PE File format structures.
4. API Resolving API’s(LoadLibrary, GetProcAddress).

We know the payload is encrypted so we don't want to dig in looking into how the file is decrypted, we want to find it decrypted.

**Static Analysis:**

I decided to first load the file in IDA and scan for strings or valuable imports:

![432x340](https://lh3.googleusercontent.com/qYa5mto-_OuRCFye53XLaQbsd9IQffe1RyPBa4R11IHxpu1RsvKPVHJEX8EUtUg3WvnCrvDIb-q_caMaQSGZ9zsVrHYJZaSkQKzEE_SCgJixxrVBLZ4rlSjE6FBl_H7CP88rL7Hp)

This is incredible - we find everything we need off the spot. Calls to HeapAlloc, VirtualAlloc, LoadLibrary, GetProcAddress and resource related functions.

Let's look at the entry point of the binary:
We’re presented with a long list of functions being called in a linear order.. not really helpful.

![120x432](https://lh5.googleusercontent.com/SRsnzD7KDpaaPSZbRgGKVGl5F2EmKNo_5K1p0Aty2zx1hhdcu4QNNtrx08IABO1r_AvQ1dO0CdK_QFBrAXpOCXl-kaO1MYJomFruJDWS2lqDak27CtWCoDP6wWtgxbEsJbwX57NT)

Before I dissect the malware further I decide to look into the resource section using Resource Hacker:

![479x232](https://lh3.googleusercontent.com/ZI9pJa95cWge_7Xf62GKoRXUAz8rt6f9rD1Og0On--VHJrOibDuibqhsmYYEtJkew0NORb04ddDo50FZWG4VPdWrIwkuXcHnASbWTGl9zs6WY4JuFBNL1EUBDi_LpvG84Es6iUgF)

A resource, it's called **DATA** and its encrypted. So let’s be on the lookup for any reference to the string “**DATA**” in memory.

Back in IDA, it's really hard to realize what's going on if we go free diving in the binary. It’s better off to start at the bottom so first let's explore the areas that are of value.

We’ll start off with the Resource API calls:

A call to **FindResourceW** is referenced at **00402B0E**:

![311x287](https://lh4.googleusercontent.com/uxQ4ODU3eBBggXjoJMWDd1ebatBtxsf8tnFf3P_il99yTG3KEmHfS_LPnXqxKYRcGu_ghGQp2aTxjvDt0tp4aX3iUX2_fFmwK2P6manvHpJmYP1LlbYVWEmDs_yXVyslWSwxlRjQ)

We can easily map out the local Variables **var_8** and **var_C** and **ESI**, We know that by stdcall convention, the return value is passed into eax from each function.

[FindResourceW ](https://docs.microsoft.com/en-us/windows/win32/api/winbase/nf-winbase-findresourcea)returns a handle of type of HRSR(Handle to a resource information block) is passed inside esi.

[SizeOfResource](https://docs.microsoft.com/en-us/windows/win32/api/libloaderapi/nf-libloaderapi-sizeofresource) returns a DWORD which represents the size of the resource in bytes, this goes into var_C

[LoadResource ](https://docs.microsoft.com/en-us/windows/win32/api/libloaderapi/nf-libloaderapi-loadresource)returns a handle of type HGLOBAL which represents a handle to the source, it is directly passed into LockResource

[LockResource ](https://docs.microsoft.com/en-us/windows/win32/api/libloaderapi/nf-libloaderapi-lockresource)returns a pointer to the first byte in the resource, this goes into var_8.

Let's rename everything in IDA so we'll have a more clear view of things:

![341x329](https://lh6.googleusercontent.com/d1_LXnSzaMUI_D4Kfosf0LP41rEi02SXAGzvf8zcZ4gfhaeobimJTVziP2Mn6JC58pOXdXFPEazC7EYQMnd6oomop3u3IY9otep4f0CgT3LyZHVnhYMURD_YifLnWqV--8Csg5C3)

Cool, now lets rename the function to something more valuable for us, so we can find it later(**sub_00402AD0** -> **LoadResourceFromMemory**)

Next let’s look at **VirtualAlloc**, we'll use the xrefs from the Import view in IDA to look up the **VirtualAlloc** API Call(can be found at **0x4029F0**):

![388x243](https://lh5.googleusercontent.com/RIRNZKgtyaPw0JLdsoXjMkIpQGlzdBnazuubClAfC90C99r0pM-_NWtLVplKKb63iOHbbkT5d6U5YgPeHsxlIrWKfCVyYpfqmGtV7plsZpz-9UiFXjiw5tn8uJsBHkNTI5JH3-0M)

We can map **var_34**, which will point to the first byte of the allocated space, it is used a lot during the program so lets rename it right now to **lpvoidPointerToAllocatedSpace**

the instruction sequence:

![303x74](https://lh5.googleusercontent.com/1lpaJv9nlF-fmRlCrbFLmfqF22K9g_Yj-9uTG0AkKccwlb2MPOtRJsG9rfiI3ZlGDV3Sgxozag996aMPFhkoYly1uLGPXF5QmDLZoFg24vooQy2Dz3t5_LlbXjDZJot12J7XyNRW)

is this an entry inside a structure or an array? I cannot tell for sure at this point.
If we scroll down, we can see **LoadLibrary** and **GetProcAddress** are being called in a loop fashion:

![602x253](https://lh6.googleusercontent.com/Ob809tO82Ngo5UcanrJzTjBUTBII7EATVcLGp1GEmcRzLZ0XiKRd9NGVnhzEI8_JGne60KrR79r0wV1HyyHSnSsLrIyme6PIRpr1S_HsGWzv16FDjX7KTXLpm3hSQktQecT1zS6k)
![602x408](https://lh5.googleusercontent.com/gpnFfuSPTVT4SJBzbRAod_NC_7H7LIcUMT4Y0dLpvmU_X4B_0BAPkE__WySyg7TCPKZtOCW1aXVvN7iFpeOFnqmQOlNWvxCC2PAF7l2DM-_HvYLMfzC6kypfYvjz_HxPQxBmlgxN)

Let’s start from the top(code block **0x4029C2**): If **EDI** is not empty, a DLLs base address will be resolved using **LoadLibraryA**. That address will be saved in **EBX**, which we can clearly see is being passed to **GetProcAddress** to get a base address of an API(code block **0x40299C**). When resolved, it’s then saved inside [**EDX**].

then at location **loc_4029AE** two local variables are incremented by four which can be represented as an indexers inside an array of pointers.

At first glance, I instantly thought about one thing, the binary is attempting to resolve the Import Address Table of another binary. but it’s really too early to make such assumptions.

Lets give this function a name(**sub_40274C** -> **ExecuteNewResolvedPEinResources**)
Now let's check who called **ExecuteNewResolvedPEinResources**, it’s **sub_402C58**. Hmm.. Interesting this function also calls **LoadResourceFromMemory**.

The caller of this function(**sub_402C58**) is the **start** function which is the entry point of the program. In addition **sub_402C58** is also the last function being called before the loader binary shuts itself down. Great! We know where to stop and what to look out for!

![346x111](https://lh3.googleusercontent.com/QJVrI3YSSoMtH0fRtyQCASM7fx8utU5D90OAfGPxbvgAAW4ujMW-Reucj3MtebzAqIJznU1eEwoSj0RcivoFToP-08VhgbcBs5UD1s2d2tT8g0QOMzyofHhROu_my20QBcQDEgVk)

**Dynamic Analysis**:

Breakpoints to set before execution:

1. LoadResourceFromMemory(**00402CA5**)
2. ExecuteNewResolvedPEinResources(**00402D7F**)
3. VirtualAlloc(**00402807**)
4. LoadLibraryA(**00402941**)
5. sub_402C58(**00402C58**)

Right so upon execution we should directly land at **sub_402C58**.

before entering **LoadResourceFromMemory**(**0x402CA5**), we can see “**DATA**” is being passed into **EAX** which is the name of the resource we saw before.
![602x41](https://lh6.googleusercontent.com/PG3JeYxz71jaISYRMdJGnFoDCAhAJt50wD_wGDOUDe90henJ4GsfG-yNsXfiZ0RSF1Bdrrrp_W_z1yQbuLg7HRczwz0W-FKC3T51Cv1Tx0loQXGY1tVw9YXX5mpqSPbOjp0IFLeS)
Then we can see that the pointer to the first byte in the loaded resource is being passed into **var_8**(**ebp-8**).

![582x68](https://lh6.googleusercontent.com/gYoG6lrfgqjSTLQrxyrJederES7pGxui0wNn2G286o2gvjSO3mXeYs0xfmjQXcWxzr-r4AOyl30PwTVp5zxq0MkgKW8Q6s1k8X2yK1wmjDPKE-xZasuqv7b12uo1lO56A7KGweSl)

but as we exit the function, we lose all reference to it, we just know its located at **0x00407064**(the resource is still encrypted.)

Looking at the code following that function, we just see a huge linear code block - calling various functions. We could go scanning these functions, but this might go into a rabbit hole I wish not enter. I’m working on the assumption that as soon as the file is going to be mapped into memory, it's going to be mapped in its decrypted form. I decide to step over most of these calls.

![293x500](https://lh3.googleusercontent.com/phAAGcZA58t7G7qAKpOoxcrdN3tm8aTpprKoLFjVd0OlIQmQVyyQWo-wXIx8U6aCxdQYAoaeedOhBXKVhZunaXsWS0579XCvz7z6SurFB6fiGXc6tAnbh4KG4Sd6sexRC88AirXS)

And what do you know - if we continue skipping these functions we’ll start seeing the string MZP being shown in the debugger. first its referenced as “M8Z” and finally before entering **ExecuteNewResolvedPEinResources** (**0x402D7E**)  We get a valid PE file header!

![602x37](https://lh3.googleusercontent.com/rr5AAMT8yBOWDftn8eP6EDjBuZVlG8D09YNJ2CzfZe46Vkm-vFjJxxHsSshFFwdDG7lpYSzX9NWNCvSiutz-9XjNK4xDYsK-QyuZ6DUx_w5VtPvAJbIpSTqo3b-cGSulQwdxXo2K)

![596x164](https://lh6.googleusercontent.com/N7YUILaI6mlinvJ2Lz_GRnLizm6qHOxAntpjdYkTWYWc0g7aoPi2MY_R2SI2P_dvF0p3wkUDJh9tMXeW6hSXL6uKu70nMVIAjzfvOjn8pqw5sXDDiE_N7Te8WKdVBFDesenscI6O)

**EDX** contains a pointer to the decrypted file, **EAX** contains the path string to the location of the loader binary and **ECX** contains value **0x00066A00**.

So let's go into **ExecuteNewResolvedPEinResources** in IDA and see if we can map this data out(yes we can!)

![561x122](https://lh5.googleusercontent.com/O2MGglp8WR_lCVnE5womT1oye2YFP2pr3lGrcWxjoEAm4EzQFilo1GVWEqyjsgJo0UEYA3ToVWyMBjU7ckBJlvVgOtTxYfVpGKcyogpVFTh2qncRRkt5-hgcwyYV-qKReJDFcXVM)

If we keep on going, nothing really happens until we hit the code block at **loc_4027BB**:

![455x94](https://lh6.googleusercontent.com/JFVeE6y7yaT6Tzg24rYCmNKg-tq1bXkgTWWdr5RUjF0HayHc6N7WDj1_rlttRYKHC-daBP_QSqQqZe8lzCDFUgqy6uCwC3-elHQEhJ55rtgKG1sSjMlnT0ZZ0SNoVzXsiGbTQpP4)

**var_38** passed by **EBX** is now a pointer to a newly allocated PE File, after calling the function(**0x4027BE**) in the block it returns that pointer into **EAX**.

If we do decide to enter that function(**0x4027BE**), it leads to a rabbit hole of more functions. I decided not to get into it(If we resolve the location of the calls to HeapAlloc, this function might eventually call it. I speculate that this function has something to do with either confusing the analyst or it attempts to map out different sections of the PE, either way it has not much value to us anyway).

**EAX** assigns this new pointer into **var_10** and **var_18** and then something interesting happens - the binary attempts to check if [**EAX**] contains the string “**ZM**”(0x5A4D). I input the data I collected inside IDA:

![452x225](https://lh5.googleusercontent.com/oltC3qS9SkZIdDT3J8Daf0RwyAcQG9enxv0ekWw0gIYJf7DenKR_rxuUHWmaGAWARjQnlxOqXgMN9KZ8jyqCaxHm0n5i6hKN-5yPNdMg9kQHzQW6LLWOOA-Q9kpUcqogFQyIIzXV)

I decide to conclude that **var_18** is actually a pointer to **IMAGE_DOS_HEADER**, well see if this assumption is correct.

At the next code block, the code loads the address of the **IMAGE_DOS_HEADER** and adds **0x3C** to it and attempts to compare it to "**EP**"( 0x4550).

![602x77](https://lh5.googleusercontent.com/5G-B8fmO386-TaGXcoL-StYcu3_YZO2RMu1y7XHrefXNWWMnKIRPN8ppNZ-JP79fKrNwGv6odqqe0bDBFm7q4USRxxTYeEkP3aiFe3lJHkKtBTjCdGNTdZd8IJh8CX6Fr7CaeCId)

**e_lfanew** is the last field in the **IMAGE_DOS_HEADER** and contains a the offset of the IMAGE_NT_HEADERS structure in the file, “**PE**” is the the value of the first field located inside **IMAGE_NT_HEADERS**, **Signature**:

![453x166](https://lh5.googleusercontent.com/JCZEIR1Yoc2CKSVOKiegHeRSY1ZX9c0zSFqgF3Ns-k_XikVUwlKrRNN3JmpWDSROfznzFY-iN9I0mwImR5-zXfAD0nPohm53hOHsxA0HxHuT2crxrWToOpaB8ncROabPM11AuiQr)

The next code block calls **VirtualAlloc**. I decide to map my assumptions into IDA:

![585x244](https://lh3.googleusercontent.com/EQECUxmd_O9EeL73Zt5cwCS4xvWM9RwZ8S8bQu_w3OUR71LdQgmqWXLsiC08OfwnDFzpVXXZKfFEjWy19bRKhCmywBJQRVXKb1PPhq8GSnX1qCJGKE1xdtTaZ-N33aRXEieuZTw8)
**SizeOfImage** field located inside the **OptionalHeader** represents the size of the binary in bytes. **EAX** plus **EAX** will contain double that size. so its for two binaries.

At this point, there is too much evidence to conclude that the loader binary is loading and mapping out the file located in the resource section “DATA”.

The next code block contains the following instructions:

![602x137](https://lh5.googleusercontent.com/wUKKAMVlib9Sl4qLo0pP_JzNf1DrW_fS9B1V1HgVCYIrPkKh-zpCzAzMKmrAAEmQeAJFKbcXo4egQ8ncAI0fcJ0otrCUfJUYYWYVvfOVoMQxo3YwLsmX-79L1PYkH6dKOPbNCjHh)

if we look through the entire block **var_14** is almost always passed in **EDX**, and looking inside the function **sub_4022B4** we can see that both **EAX** and **EDX** are being used. **EAX** when passed to this function will point past the entire size of the PE file. while **EDX** will contain random data. If we’ll dig even deeper inside **sub_4022B4**. we can see the data contained in **EDX** is being written on the boundary allocated previously for the second PE file! so let’s rename everything:

![489x119](https://lh5.googleusercontent.com/FoHx2zdblE0sFQcm36oL5IQqTHVJ4n1P0x3f_NSn5J-Kk9_fkpe_20aspsptgNcaWBJvdjUoNOgtQdNBG0-S6j5Ds1KtDmBsqg4AktLmadZS8qxz27ZKt8VdLMdREOt-dFOXWyo0)

If we keep reversing this entire code block, the main conclusion is the code block is copying the first resource binary we found to **lpvoidPointedToNewAllocatedAreaForImage**+**SizeOfImage**+4. then at **0x0040287D**, the resource binary is being copied again to **lpvoidPointedToNewAllocatedAreaForImage**.

These two binaries are separated by a boundary contained in the variable **lpvoidDataToPopulate**( contains the value **0x66A00**)
We rename sub_4022B4 to **MapMemoryData**, and var_14 will be renamed to **lpvoidDataToPopulate**.

Re-mapped view of IDA:

![391x503](https://lh5.googleusercontent.com/yaqa_gizDbxA0EAkjp6RaBXzeG1nBmr9HFbSSkkaw6ShPdt4MVEFKz82PuJeem4KV4-ShDWsSnZ8dGNfK86Ewa0K3D4Nc5GzBE1k3otJb8oR0gfR1mh-3Ltl4i7B7Po3L-GPhanf)

Boundary value:

![592x49](https://lh5.googleusercontent.com/8Oc61eUPgm8doa_YPtmhLefz_POLswDvP6bPef16BxHJ6vjyqwkndtzDQwmrJwYt5cZmnsmRKcLYfVFyzjmz7Pq774hA7Q1Rmtf2RHBdMW_pOLkL92C3VqlIkPpqIk3u1jJISUTQ)

we move on to the code block located at **0x00402891**:

![602x217](https://lh4.googleusercontent.com/I_AMF2djN456mBhgO_I9sRt2rZBF8_R3X0cIghmLm61NJfxkoeAAnY7ZWhOm8ql8NlyLVLVkkzJhJZvxYexbmUWO3hPJ9jmLW_jcnCQDYvUBgPYmARYyBlTcg7eu_C__nYFXn-kT)

This loop goes through all the sections located within the resource and maps them into the newly allocated memory.

![460x428](https://lh5.googleusercontent.com/E84EM8yJVgWDbqGTfPr3wnb6oZDb4MqfHge2Ncgqmpwil-iS9D9i98_DFZy9eJ0DN4qvzS0iiqgp9yXBa6YZHu4W2C-qgUVCdY4_AzM-vkK4s0DzVDRzL6m242zMJM7LNQPk5Zuv)

This can be observed in the debugger if we access and view the dump of **EAX** before call to **MapMemoryData** and after the call. it should be noted that the sections are being mapped into the first memory area allocated for the PE from the resource sections and not the second.
![602x99](https://lh6.googleusercontent.com/aiYaASnv7QK3dVzeQagqN74PIG47ID_ukdGBMogduZcSpDIqMgKdBHI1astg5423wcT-KIqEwFOr63j3zg_miDQG1H_wDqnjcAFdYiUZCpZfdCQ9cVMnrz_fShjKPN1iKsNtUR0q)
At **0x4028EC**, we can see that the ImageBase of the resource binary in memory is being changed, this field located in IMAGE_OPTIONAL_HEADER is usually set for 0x400000 for binaries but it's being changed, to point to the memory pointed by the new allocated memory for the binary.

![579x191](https://lh6.googleusercontent.com/Llf7KMyjhsXsNJPH6lFwHNmDmOaUexTz2P9JXHVFqGCfeOFzSaffr1RhagX3mHaA0GmKKY59iRMgFNZygNEVWKHek8Ty-oOMvCW5mHnXJ3ST7Bj_2RiYut2bpqtx82iSsC4nQKJ4)

In the next block it gets really interesting(**0x4029B6**):

A loop begins to resolve the IAT, of the second area allocated for the binary mapped into memory. I will not bother explaining this in depth but this entire thing occurs in this loop which is described in this diagram:

![602x284](https://lh3.googleusercontent.com/ls6LJ62isculhy8Gi0CoVtvkUkWJZ53WUoKdeRZOxsXqDRx_pFDVnASvy6SX59TMku8eo2dAeAgsS8qVSSAU_fXJLS0dTD8b47YrPVnFIr-IePc4S8BoR6xF4V12IrDlv7zwBee_)
![602x497](https://lh4.googleusercontent.com/ExwXLqPQl3qca-GJlWxl-frgeU6GK9VCWeDVVm3Isz7qRd4wTgbuCiHuodAKKerSLe5xoHR5jz2ke_tWIZxtCnZCaHCENj5FSM0p7c6EHcSQIyqLwL8Yj4ygVyoVRlI6zYX84Shi)

And now finally, after iterating resolving the IAT we jump into **loc_4029D0**.

![534x246](https://lh3.googleusercontent.com/ff6E5Y9E0vhrlOWeGKbE9P4wgkEC5wcDdezlwo0GP-s8mnK_HhHziUWuq0K9Fd3krpAnUv72sC8tu_IyGgDlvW1zRC5KW9yDcGwExJmcQpaqmGP6V5754yuJP2_KZHulRtEeMqUt)

The address of the entry point of the binary is passed into **var_8**, and then it is called. the two loaded binaries depending on each other to execute, one is going to execute its code and the other contains resolved IAT addresses. 

Lets create a UML diagram detailing how this loader operates so it would be more clear what just happened and it would also be easier for us to understand the loading of payload.

![551x302](https://lh4.googleusercontent.com/KPZcmwl5DxED2sSefQ7BykooskbEH5WxOaWHiB0mwyS6soqm4x--mW0MYsOx3H1blURIwiu_Gfa4OQS8LdPjZGSAU6OoCbyzAYZziF1W8M5D3eUS6NA52DsxivQ5O56PTJO4__3b)

**Conclusion**:
In this article, I demonstrated how a malware might hide itself in memory by loading its encrypted payload into itself, thus attempting to stay undetectable and to avoid dropping files on disk.

In the next part of this series we’ll be exploring how malware might use PowerShell and the Registry to execute a File-less attack.

**Resources used:**
[PE File Format](http://www.openrce.org/reference_library/files/reference/PE%20Format.pdf)
[Untangling Kovter’s persistence methods](https://blog.malwarebytes.com/threat-analysis/2016/07/untangling-kovter/)
